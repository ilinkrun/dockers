"""
사용자 관리 서버, 데이터베이스 서버 등 공유 자원 관리에 해당하는 서버 구축도 필요합니다.

사용자 관리 서버
- 사용자/인증/권한 관리

데이터베이스 서버 관리
- 프로젝트별 별도 디비 생성
"""

멋진 확장 계획이네요! 공유 자원을 중앙집중식으로 관리하는 **인프라 서비스 레이어**를 구축해보겠습니다. 이를 통해 모든 프로젝트가 공통으로 사용할 수 있는 사용자 관리와 데이터베이스 서비스를 제공할 수 있습니다.

## 🏗️ 전체 인프라 아키텍처

### 1. **업데이트된 워크스페이스 구조**

```
workspace/
├── infrastructure/                  # 공유 인프라 서비스
│   ├── auth-service/               # 사용자 관리 서비스
│   │   ├── src/
│   │   │   ├── controllers/
│   │   │   │   ├── authController.js
│   │   │   │   ├── userController.js
│   │   │   │   └── permissionController.js
│   │   │   ├── services/
│   │   │   │   ├── authService.js
│   │   │   │   ├── userService.js
│   │   │   │   ├── permissionService.js
│   │   │   │   ├── jwtService.js
│   │   │   │   └── emailService.js
│   │   │   ├── models/
│   │   │   │   ├── User.js
│   │   │   │   ├── Role.js
│   │   │   │   ├── Permission.js
│   │   │   │   ├── UserRole.js
│   │   │   │   ├── Project.js
│   │   │   │   └── UserProject.js
│   │   │   ├── middleware/
│   │   │   │   ├── auth.js
│   │   │   │   ├── rbac.js
│   │   │   │   ├── rateLimiter.js
│   │   │   │   └── validation.js
│   │   │   ├── routes/
│   │   │   │   ├── auth.js
│   │   │   │   ├── users.js
│   │   │   │   ├── roles.js
│   │   │   │   └── projects.js
│   │   │   ├── graphql/
│   │   │   │   ├── schemas/
│   │   │   │   │   ├── auth.graphql
│   │   │   │   │   ├── user.graphql
│   │   │   │   │   └── permission.graphql
│   │   │   │   └── resolvers/
│   │   │   │       ├── authResolvers.js
│   │   │   │       ├── userResolvers.js
│   │   │   │       └── permissionResolvers.js
│   │   │   ├── utils/
│   │   │   │   ├── encryption.js
│   │   │   │   ├── validators.js
│   │   │   │   └── constants.js
│   │   │   ├── config/
│   │   │   │   ├── database.js
│   │   │   │   ├── redis.js
│   │   │   │   └── jwt.js
│   │   │   └── app.js
│   │   ├── migrations/
│   │   ├── seeds/
│   │   ├── tests/
│   │   ├── docker/
│   │   │   └── Dockerfile
│   │   ├── .env.example
│   │   └── package.json
│   ├── database-service/           # 데이터베이스 관리 서비스
│   │   ├── src/
│   │   │   ├── controllers/
│   │   │   │   ├── databaseController.js
│   │   │   │   ├── migrationController.js
│   │   │   │   └── backupController.js
│   │   │   ├── services/
│   │   │   │   ├── databaseService.js
│   │   │   │   ├── migrationService.js
│   │   │   │   ├── backupService.js
│   │   │   │   └── monitoringService.js
│   │   │   ├── models/
│   │   │   │   ├── DatabaseInstance.js
│   │   │   │   ├── Migration.js
│   │   │   │   └── Backup.js
│   │   │   ├── templates/
│   │   │   │   ├── mysql-template.sql
│   │   │   │   └── postgresql-template.sql
│   │   │   ├── scripts/
│   │   │   │   ├── createDatabase.js
│   │   │   │   ├── dropDatabase.js
│   │   │   │   └── migrateDatabase.js
│   │   │   └── app.js
│   │   ├── docker/
│   │   │   └── Dockerfile
│   │   └── package.json
│   ├── api-gateway/                # API 게이트웨이
│   │   ├── src/
│   │   │   ├── gateway/
│   │   │   │   ├── authGateway.js
│   │   │   │   ├── projectGateway.js
│   │   │   │   └── databaseGateway.js
│   │   │   ├── middleware/
│   │   │   │   ├── authentication.js
│   │   │   │   ├── authorization.js
│   │   │   │   ├── logging.js
│   │   │   │   └── rateLimit.js
│   │   │   ├── routes/
│   │   │   │   ├── proxy.js
│   │   │   │   └── health.js
│   │   │   └── app.js
│   │   └── package.json
│   ├── shared-database/            # 공유 데이터베이스 설정
│   │   ├── postgresql/
│   │   │   ├── init/
│   │   │   │   ├── 01-create-auth-db.sql
│   │   │   │   └── 02-create-management-db.sql
│   │   │   └── docker-compose.yml
│   │   └── mysql/
│   │       ├── init/
│   │       └── docker-compose.yml
│   ├── monitoring/                 # 모니터링 서비스
│   │   ├── prometheus/
│   │   ├── grafana/
│   │   └── elasticsearch/
│   └── docker-compose.yml         # 전체 인프라 orchestration
├── management-hub/                 # 기존 관리 허브 (확장)
│   ├── frontend/
│   │   └── pages/
│   │       ├── infrastructure/     # 인프라 관리 페이지
│   │       │   ├── auth-service/
│   │       │   ├── databases/
│   │       │   └── monitoring/
│   │       └── users/              # 통합 사용자 관리
│   └── backend/
│       └── src/
│           ├── services/
│           │   ├── authProxyService.js
│           │   └── databaseProxyService.js
│           └── middleware/
│               └── infraAuth.js
└── projects/                       # 개별 프로젝트들
    ├── project-1/
    │   ├── backend/
    │   │   └── src/
    │   │       ├── middleware/
    │   │       │   └── authProxy.js    # 인프라 서비스 연동
    │   │       └── config/
    │   │           └── database.js     # 동적 DB 설정
    │   └── frontend/
    │       └── lib/
    │           └── auth.js             # 통합 인증 클라이언트
    └── project-2/
        └── [같은 구조]
```

## 🔐 사용자 관리 서비스 (Auth Service)

### 1. **사용자 관리 서비스 핵심 구현**

#### **사용자 모델 (models/User.js)**
```javascript
const { DataTypes } = require('sequelize');
const bcrypt = require('bcryptjs');

module.exports = (sequelize) => {
  const User = sequelize.define('User', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true
      }
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        len: [3, 50]
      }
    },
    firstName: {
      type: DataTypes.STRING,
      allowNull: false
    },
    lastName: {
      type: DataTypes.STRING,
      allowNull: false
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        len: [8, 100]
      }
    },
    avatar: {
      type: DataTypes.STRING,
      allowNull: true
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true
    },
    isEmailVerified: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    lastLoginAt: {
      type: DataTypes.DATE,
      allowNull: true
    },
    passwordResetToken: {
      type: DataTypes.STRING,
      allowNull: true
    },
    passwordResetExpires: {
      type: DataTypes.DATE,
      allowNull: true
    },
    emailVerificationToken: {
      type: DataTypes.STRING,
      allowNull: true
    },
    loginAttempts: {
      type: DataTypes.INTEGER,
      defaultValue: 0
    },
    lockUntil: {
      type: DataTypes.DATE,
      allowNull: true
    }
  }, {
    timestamps: true,
    hooks: {
      beforeCreate: async (user) => {
        if (user.password) {
          user.password = await bcrypt.hash(user.password, 12);
        }
      },
      beforeUpdate: async (user) => {
        if (user.changed('password')) {
          user.password = await bcrypt.hash(user.password, 12);
        }
      }
    }
  });

  // 인스턴스 메서드
  User.prototype.comparePassword = async function(candidatePassword) {
    return await bcrypt.compare(candidatePassword, this.password);
  };

  User.prototype.isLocked = function() {
    return !!(this.lockUntil && this.lockUntil > Date.now());
  };

  User.prototype.incLoginAttempts = async function() {
    if (this.lockUntil && this.lockUntil < Date.now()) {
      return this.update({
        loginAttempts: 1,
        lockUntil: null
      });
    }

    const updates = { loginAttempts: this.loginAttempts + 1 };
    
    if (this.loginAttempts + 1 >= 5 && !this.isLocked()) {
      updates.lockUntil = Date.now() + 2 * 60 * 60 * 1000; // 2시간 잠금
    }

    return this.update(updates);
  };

  User.prototype.resetLoginAttempts = async function() {
    return this.update({
      loginAttempts: 0,
      lockUntil: null
    });
  };

  // 연관관계
  User.associate = (models) => {
    User.belongsToMany(models.Role, {
      through: models.UserRole,
      foreignKey: 'userId',
      as: 'roles'
    });
    
    User.belongsToMany(models.Project, {
      through: models.UserProject,
      foreignKey: 'userId',
      as: 'projects'
    });
  };

  return User;
};
```

#### **역할 및 권한 모델 (models/Role.js, models/Permission.js)**
```javascript
// models/Role.js
module.exports = (sequelize, DataTypes) => {
  const Role = sequelize.define('Role', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: true
    },
    isSystem: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  });

  Role.associate = (models) => {
    Role.belongsToMany(models.User, {
      through: models.UserRole,
      foreignKey: 'roleId',
      as: 'users'
    });
    
    Role.belongsToMany(models.Permission, {
      through: 'RolePermissions',
      foreignKey: 'roleId',
      as: 'permissions'
    });
  };

  return Role;
};

// models/Permission.js
module.exports = (sequelize, DataTypes) => {
  const Permission = sequelize.define('Permission', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    resource: {
      type: DataTypes.STRING,
      allowNull: false
    },
    action: {
      type: DataTypes.ENUM('create', 'read', 'update', 'delete', 'manage'),
      allowNull: false
    },
    scope: {
      type: DataTypes.ENUM('global', 'project', 'own'),
      defaultValue: 'project'
    },
    description: {
      type: DataTypes.TEXT
    }
  });

  Permission.associate = (models) => {
    Permission.belongsToMany(models.Role, {
      through: 'RolePermissions',
      foreignKey: 'permissionId',
      as: 'roles'
    });
  };

  return Permission;
};

// models/Project.js
module.exports = (sequelize, DataTypes) => {
  const Project = sequelize.define('Project', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false
    },
    slug: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    description: {
      type: DataTypes.TEXT
    },
    status: {
      type: DataTypes.ENUM('active', 'inactive', 'archived'),
      defaultValue: 'active'
    },
    settings: {
      type: DataTypes.JSONB,
      defaultValue: {}
    },
    databaseConfig: {
      type: DataTypes.JSONB,
      allowNull: true
    }
  });

  Project.associate = (models) => {
    Project.belongsToMany(models.User, {
      through: models.UserProject,
      foreignKey: 'projectId',
      as: 'users'
    });
  };

  return Project;
};
```

#### **인증 서비스 (services/authService.js)**
```javascript
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { User, Role, Permission, Project } = require('../models');
const emailService = require('./emailService');
const config = require('../config');

class AuthService {
  // 사용자 등록
  async register(userData) {
    const { email, username, firstName, lastName, password } = userData;
    
    // 중복 검사
    const existingUser = await User.findOne({
      where: {
        [Op.or]: [{ email }, { username }]
      }
    });

    if (existingUser) {
      throw new Error('이미 존재하는 이메일 또는 사용자명입니다.');
    }

    // 이메일 검증 토큰 생성
    const emailVerificationToken = crypto.randomBytes(32).toString('hex');

    // 사용자 생성
    const user = await User.create({
      email,
      username,
      firstName,
      lastName,
      password,
      emailVerificationToken
    });

    // 기본 역할 할당 (USER)
    const userRole = await Role.findOne({ where: { name: 'USER' } });
    if (userRole) {
      await user.addRole(userRole);
    }

    // 이메일 검증 메일 발송
    await emailService.sendEmailVerification(user.email, emailVerificationToken);

    return {
      user: this.sanitizeUser(user),
      message: '회원가입이 완료되었습니다. 이메일을 확인해주세요.'
    };
  }

  // 로그인
  async login(email, password, projectId = null) {
    const user = await User.findOne({
      where: { email },
      include: [
        {
          model: Role,
          as: 'roles',
          include: [{
            model: Permission,
            as: 'permissions'
          }]
        },
        {
          model: Project,
          as: 'projects'
        }
      ]
    });

    if (!user) {
      throw new Error('이메일 또는 비밀번호가 올바르지 않습니다.');
    }

    // 계정 잠금 확인
    if (user.isLocked()) {
      throw new Error('계정이 일시적으로 잠겨있습니다. 나중에 다시 시도해주세요.');
    }

    // 비밀번호 확인
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      await user.incLoginAttempts();
      throw new Error('이메일 또는 비밀번호가 올바르지 않습니다.');
    }

    // 계정 상태 확인
    if (!user.isActive) {
      throw new Error('비활성화된 계정입니다.');
    }

    // 로그인 성공 처리
    await user.resetLoginAttempts();
    await user.update({ lastLoginAt: new Date() });

    // JWT 토큰 생성
    const tokens = await this.generateTokens(user, projectId);

    return {
      user: this.sanitizeUser(user),
      tokens,
      permissions: this.extractPermissions(user),
      projects: user.projects
    };
  }

  // JWT 토큰 생성
  async generateTokens(user, projectId = null) {
    const payload = {
      userId: user.id,
      email: user.email,
      username: user.username,
      projectId,
      roles: user.roles?.map(role => role.name) || []
    };

    const accessToken = jwt.sign(payload, config.jwt.accessSecret, {
      expiresIn: config.jwt.accessExpiresIn
    });

    const refreshToken = jwt.sign(
      { userId: user.id },
      config.jwt.refreshSecret,
      { expiresIn: config.jwt.refreshExpiresIn }
    );

    return { accessToken, refreshToken };
  }

  // 토큰 검증
  async verifyToken(token, type = 'access') {
    const secret = type === 'access' ? config.jwt.accessSecret : config.jwt.refreshSecret;
    
    try {
      const decoded = jwt.verify(token, secret);
      const user = await User.findByPk(decoded.userId, {
        include: [
          {
            model: Role,
            as: 'roles',
            include: [{
              model: Permission,
              as: 'permissions'
            }]
          }
        ]
      });

      if (!user || !user.isActive) {
        throw new Error('유효하지 않은 사용자입니다.');
      }

      return { user, decoded };
    } catch (error) {
      throw new Error('토큰이 유효하지 않습니다.');
    }
  }

  // 권한 확인
  async hasPermission(userId, resource, action, projectId = null, scope = 'project') {
    const user = await User.findByPk(userId, {
      include: [
        {
          model: Role,
          as: 'roles',
          include: [{
            model: Permission,
            as: 'permissions',
            where: {
              resource,
              action: { [Op.in]: [action, 'manage'] }
            }
          }]
        },
        {
          model: Project,
          as: 'projects',
          ...(projectId && { where: { id: projectId } })
        }
      ]
    });

    if (!user) return false;

    // 시스템 관리자는 모든 권한
    const isAdmin = user.roles.some(role => role.name === 'ADMIN');
    if (isAdmin) return true;

    // 권한 확인 로직
    for (const role of user.roles) {
      for (const permission of role.permissions) {
        if (permission.resource === resource && 
            (permission.action === action || permission.action === 'manage')) {
          
          // 스코프 확인
          if (permission.scope === 'global') return true;
          
          if (permission.scope === 'project' && projectId) {
            const hasProjectAccess = user.projects.some(project => project.id === projectId);
            if (hasProjectAccess) return true;
          }
          
          if (permission.scope === 'own') {
            // 본인 리소스에 대한 접근 (추가 로직 필요)
            return true;
          }
        }
      }
    }

    return false;
  }

  // 프로젝트 접근 권한 확인
  async hasProjectAccess(userId, projectId) {
    const user = await User.findByPk(userId, {
      include: [{
        model: Project,
        as: 'projects',
        where: { id: projectId }
      }]
    });

    return user && user.projects.length > 0;
  }

  // 사용자 정보 정제
  sanitizeUser(user) {
    const { password, passwordResetToken, emailVerificationToken, ...sanitized } = user.toJSON();
    return sanitized;
  }

  // 권한 추출
  extractPermissions(user) {
    const permissions = new Set();
    
    user.roles?.forEach(role => {
      role.permissions?.forEach(permission => {
        permissions.add(`${permission.resource}:${permission.action}:${permission.scope}`);
      });
    });

    return Array.from(permissions);
  }
}

module.exports = new AuthService();
```

## 🗄️ 데이터베이스 관리 서비스

### 2. **데이터베이스 서비스 핵심 구현**

#### **데이터베이스 서비스 (services/databaseService.js)**
```javascript
const { Client } = require('pg');
const mysql = require('mysql2/promise');
const fs = require('fs-extra');
const path = require('path');
const { DatabaseInstance, Migration } = require('../models');

class DatabaseService {
  constructor() {
    this.adminConnections = {
      postgresql: {
        host: process.env.POSTGRES_HOST || 'localhost',
        port: process.env.POSTGRES_PORT || 5432,
        user: process.env.POSTGRES_ADMIN_USER || 'postgres',
        password: process.env.POSTGRES_ADMIN_PASSWORD,
        database: 'postgres'
      },
      mysql: {
        host: process.env.MYSQL_HOST || 'localhost',
        port: process.env.MYSQL_PORT || 3306,
        user: process.env.MYSQL_ADMIN_USER || 'root',
        password: process.env.MYSQL_ADMIN_PASSWORD,
        database: 'mysql'
      }
    };
  }

  // 프로젝트 데이터베이스 생성
  async createProjectDatabase(projectId, config) {
    const { type, name, options = {} } = config;
    
    try {
      let connection;
      let result;

      if (type === 'postgresql') {
        result = await this.createPostgreSQLDatabase(projectId, name, options);
      } else if (type === 'mysql') {
        result = await this.createMySQLDatabase(projectId, name, options);
      } else {
        throw new Error(`지원하지 않는 데이터베이스 타입: ${type}`);
      }

      // 데이터베이스 인스턴스 정보 저장
      const dbInstance = await DatabaseInstance.create({
        projectId,
        name,
        type,
        host: this.adminConnections[type].host,
        port: this.adminConnections[type].port,
        username: result.username,
        password: result.password,
        connectionString: result.connectionString,
        status: 'active',
        config: options
      });

      return {
        success: true,
        database: dbInstance,
        credentials: {
          host: dbInstance.host,
          port: dbInstance.port,
          database: dbInstance.name,
          username: dbInstance.username,
          password: dbInstance.password,
          connectionString: dbInstance.connectionString
        }
      };
    } catch (error) {
      throw new Error(`데이터베이스 생성 실패: ${error.message}`);
    }
  }

  // PostgreSQL 데이터베이스 생성
  async createPostgreSQLDatabase(projectId, dbName, options) {
    const client = new Client(this.adminConnections.postgresql);
    
    try {
      await client.connect();

      // 사용자 생성
      const username = `${projectId}_user`.replace(/-/g, '_');
      const password = this.generatePassword();

      await client.query(`
        CREATE USER "${username}" WITH PASSWORD '${password}'
      `);

      // 데이터베이스 생성
      await client.query(`
        CREATE DATABASE "${dbName}" 
        OWNER "${username}" 
        ENCODING 'UTF8'
      `);

      // 권한 부여
      await client.query(`
        GRANT ALL PRIVILEGES ON DATABASE "${dbName}" TO "${username}"
      `);

      const connectionString = `postgresql://${username}:${password}@${this.adminConnections.postgresql.host}:${this.adminConnections.postgresql.port}/${dbName}`;

      return {
        username,
        password,
        connectionString
      };
    } finally {
      await client.end();
    }
  }

  // MySQL 데이터베이스 생성
  async createMySQLDatabase(projectId, dbName, options) {
    const connection = await mysql.createConnection(this.adminConnections.mysql);
    
    try {
      // 데이터베이스 생성
      await connection.execute(`CREATE DATABASE \`${dbName}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci`);

      // 사용자 생성
      const username = `${projectId}_user`.replace(/-/g, '_');
      const password = this.generatePassword();

      await connection.execute(`
        CREATE USER '${username}'@'%' IDENTIFIED BY '${password}'
      `);

      // 권한 부여
      await connection.execute(`
        GRANT ALL PRIVILEGES ON \`${dbName}\`.* TO '${username}'@'%'
      `);

      await connection.execute('FLUSH PRIVILEGES');

      const connectionString = `mysql://${username}:${password}@${this.adminConnections.mysql.host}:${this.adminConnections.mysql.port}/${dbName}`;

      return {
        username,
        password,
        connectionString
      };
    } finally {
      await connection.end();
    }
  }

  // 데이터베이스 삭제
  async deleteProjectDatabase(projectId) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('데이터베이스를 찾을 수 없습니다.');
    }

    try {
      if (dbInstance.type === 'postgresql') {
        await this.deletePostgreSQLDatabase(dbInstance);
      } else if (dbInstance.type === 'mysql') {
        await this.deleteMySQLDatabase(dbInstance);
      }

      // 상태 업데이트
      await dbInstance.update({ status: 'deleted', deletedAt: new Date() });

      return { success: true };
    } catch (error) {
      throw new Error(`데이터베이스 삭제 실패: ${error.message}`);
    }
  }

  // 마이그레이션 실행
  async runMigration(projectId, migrationScript) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('데이터베이스를 찾을 수 없습니다.');
    }

    try {
      let connection;
      
      if (dbInstance.type === 'postgresql') {
        connection = new Client({
          connectionString: dbInstance.connectionString
        });
        await connection.connect();
        await connection.query(migrationScript);
      } else if (dbInstance.type === 'mysql') {
        connection = await mysql.createConnection({
          host: dbInstance.host,
          port: dbInstance.port,
          user: dbInstance.username,
          password: dbInstance.password,
          database: dbInstance.name
        });
        await connection.execute(migrationScript);
      }

      // 마이그레이션 이력 저장
      await Migration.create({
        projectId,
        databaseInstanceId: dbInstance.id,
        script: migrationScript,
        status: 'completed',
        executedAt: new Date()
      });

      return { success: true };
    } catch (error) {
      // 실패한 마이그레이션 이력 저장
      await Migration.create({
        projectId,
        databaseInstanceId: dbInstance.id,
        script: migrationScript,
        status: 'failed',
        error: error.message,
        executedAt: new Date()
      });

      throw new Error(`마이그레이션 실행 실패: ${error.message}`);
    }
  }

  // 데이터베이스 백업
  async backupProjectDatabase(projectId) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('데이터베이스를 찾을 수 없습니다.');
    }

    const backupPath = path.join(
      process.env.BACKUP_PATH || '/tmp/backups',
      `${projectId}_${Date.now()}.sql`
    );

    try {
      if (dbInstance.type === 'postgresql') {
        await this.backupPostgreSQL(dbInstance, backupPath);
      } else if (dbInstance.type === 'mysql') {
        await this.backupMySQL(dbInstance, backupPath);
      }

      return {
        success: true,
        backupPath,
        size: (await fs.stat(backupPath)).size
      };
    } catch (error) {
      throw new Error(`백업 실패: ${error.message}`);
    }
  }

  // 데이터베이스 복원
  async restoreProjectDatabase(projectId, backupPath) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('데이터베이스를 찾을 수 없습니다.');
    }

    if (!await fs.pathExists(backupPath)) {
      throw new Error('백업 파일을 찾을 수 없습니다.');
    }

    try {
      if (dbInstance.type === 'postgresql') {
        await this.restorePostgreSQL(dbInstance, backupPath);
      } else if (dbInstance.type === 'mysql') {
        await this.restoreMySQL(dbInstance, backupPath);
      }

      return { success: true };
    } catch (error) {
      throw new Error(`복원 실패: ${error.message}`);
    }
  }

  // 헬퍼 메서드들
  generatePassword(length = 16) {
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
  }

  async backupPostgreSQL(dbInstance, backupPath) {
    const { spawn } = require('child_process');
    
    return new Promise((resolve, reject) => {
      const pgDump = spawn('pg_dump', [
        '-h', dbInstance.host,
        '-p', dbInstance.port,
        '-U', dbInstance.username,
        '-d', dbInstance.name,
        '-f', backupPath,
        '--verbose'
      ], {
        env: { ...process.env, PGPASSWORD: dbInstance.password }
      });

      pgDump.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`pg_dump 실행 실패: exit code ${code}`));
        }
      });
    });
  }

  async backupMySQL(dbInstance, backupPath) {
    const { spawn } = require('child_process');
    
    return new Promise((resolve, reject) => {
      const mysqldump = spawn('mysqldump', [
        '-h', dbInstance.host,
        '-P', dbInstance.port,
        '-u', dbInstance.username,
        `-p${dbInstance.password}`,
        dbInstance.name
      ]);

      const writeStream = fs.createWriteStream(backupPath);
      mysqldump.stdout.pipe(writeStream);

      mysqldump.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`mysqldump 실행 실패: exit code ${code}`));
        }
      });
    });
  }
}

module.exports = new DatabaseService();
```

## 🌐 API 게이트웨이 및 통합

### 3. **API 게이트웨이 구현**

#### **인증 미들웨어 (middleware/authentication.js)**
```javascript
const axios = require('axios');
const jwt = require('jsonwebtoken');

class AuthenticationMiddleware {
  constructor() {
    this.authServiceUrl = process.env.AUTH_SERVICE_URL || 'http://auth-service:20100';
  }

  // JWT 토큰 검증
  async verifyToken(req, res, next) {
    try {
      const token = this.extractToken(req);
      
      if (!token) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NO_TOKEN'
        });
      }

      // Auth 서비스에서 토큰 검증
      const response = await axios.post(`${this.authServiceUrl}/api/auth/verify`, {
        token
      });

      if (response.data.success) {
        req.user = response.data.user;
        req.permissions = response.data.permissions;
        next();
      } else {
        return res.status(401).json({
          error: 'Invalid token',
          code: 'INVALID_TOKEN'
        });
      }
    } catch (error) {
      console.error('Token verification failed:', error);
      return res.status(401).json({
        error: 'Authentication failed',
        code: 'AUTH_FAILED'
      });
    }
  }

  // 권한 확인 미들웨어
  checkPermission(resource, action, scope = 'project') {
    return async (req, res, next) => {
      try {
        if (!req.user) {
          return res.status(401).json({
            error: 'Authentication required',
            code: 'NO_AUTH'
          });
        }

        const projectId = req.params.projectId || req.body.projectId || req.query.projectId;
        
        const response = await axios.post(`${this.authServiceUrl}/api/auth/check-permission`, {
          userId: req.user.id,
          resource,
          action,
          projectId,
          scope
        });

        if (response.data.hasPermission) {
          next();
        } else {
          return res.status(403).json({
            error: 'Insufficient permissions',
            code: 'FORBIDDEN',
            required: `${resource}:${action}:${scope}`
          });
        }
      } catch (error) {
        console.error('Permission check failed:', error);
        return res.status(500).json({
          error: 'Permission check failed',
          code: 'PERMISSION_CHECK_FAILED'
        });
      }
    };
  }

  // 프로젝트 접근 권한 확인
  async checkProjectAccess(req, res, next) {
    try {
      const projectId = req.params.projectId || req.body.projectId;
      
      if (!projectId) {
        return res.status(400).json({
          error: 'Project ID required',
          code: 'MISSING_PROJECT_ID'
        });
      }

      const response = await axios.post(`${this.authServiceUrl}/api/auth/check-project-access`, {
        userId: req.user.id,
        projectId
      });

      if (response.data.hasAccess) {
        req.project = response.data.project;
        next();
      } else {
        return res.status(403).json({
          error: 'Project access denied',
          code: 'PROJECT_ACCESS_DENIED'
        });
      }
    } catch (error) {
      console.error('Project access check failed:', error);
      return res.status(500).json({
        error: 'Project access check failed',
        code: 'PROJECT_ACCESS_CHECK_FAILED'
      });
    }
  }

  extractToken(req) {
    const authHeader = req.headers.authorization;
    
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }
    
    return req.cookies?.token || null;
  }
}

module.exports = new AuthenticationMiddleware();
```

## 🐳 Docker 통합 설정

### 4. **인프라 Docker Compose (infrastructure/docker-compose.yml)**

```yaml
version: '3.8'

services:
  # 공유 데이터베이스
  shared-postgres:
    image: postgres:15
    container_name: shared-postgres
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - shared_postgres_data:/var/lib/postgresql/data
      - ./shared-database/postgresql/init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - infrastructure

  shared-mysql:
    image: mysql:8.0
    container_name: shared-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}
      MYSQL_DATABASE: management
    volumes:
      - shared_mysql_data:/var/lib/mysql
      - ./shared-database/mysql/init:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
    networks:
      - infrastructure

  # Redis (세션, 캐시)
  redis:
    image: redis:7-alpine
    container_name: shared-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - infrastructure

  # 사용자 관리 서비스
  auth-service:
    build: ./auth-service
    container_name: auth-service
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/auth_db
      REDIS_URL: redis://redis:6379
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
      EMAIL_SERVICE_URL: ${EMAIL_SERVICE_URL}
    depends_on:
      - shared-postgres
      - redis
    ports:
      - "20101:20100"
    volumes:
      - ./auth-service:/app
      - /app/node_modules
    networks:
      - infrastructure

  # 데이터베이스 관리 서비스
  database-service:
    build: ./database-service
    container_name: database-service
    environment:
      NODE_ENV: production
      POSTGRES_ADMIN_HOST: shared-postgres
      POSTGRES_ADMIN_USER: postgres
      POSTGRES_ADMIN_PASSWORD: ${POSTGRES_PASSWORD}
      MYSQL_ADMIN_HOST: shared-mysql
      MYSQL_ADMIN_USER: root
      MYSQL_ADMIN_PASSWORD: ${MYSQL_PASSWORD}
      BACKUP_PATH: /backups
    depends_on:
      - shared-postgres
      - shared-mysql
    ports:
      - "3002:20100"
    volumes:
      - ./database-service:/app
      - /app/node_modules
      - database_backups:/backups
    networks:
      - infrastructure

  # API 게이트웨이
  api-gateway:
    build: ./api-gateway
    container_name: api-gateway
    environment:
      NODE_ENV: production
      AUTH_SERVICE_URL: http://auth-service:20100
      DATABASE_SERVICE_URL: http://database-service:20100
    depends_on:
      - auth-service
      - database-service
    ports:
      - "20100:20100"
    volumes:
      - ./api-gateway:/app
      - /app/node_modules
    networks:
      - infrastructure
      - projects

  # 모니터링 - Prometheus
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - infrastructure

  # 모니터링 - Grafana
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
    ports:
      - "3003:20100"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
    networks:
      - infrastructure

volumes:
  shared_postgres_data:
  shared_mysql_data:
  redis_data:
  database_backups:
  prometheus_data:
  grafana_data:

networks:
  infrastructure:
    driver: bridge
  projects:
    driver: bridge
    external: true
```

## 🔧 프로젝트 연동 설정

### 5. **프로젝트별 인프라 연동**

#### **프로젝트 인증 미들웨어 (projects/project-1/backend/middleware/authProxy.js)**
```javascript
const axios = require('axios');

class AuthProxy {
  constructor() {
    this.apiGatewayUrl = process.env.API_GATEWAY_URL || 'http://api-gateway:20100';
  }

  // 인증 미들웨어
  authenticate() {
    return async (req, res, next) => {
      try {
        const token = this.extractToken(req);
        
        if (!token) {
          return res.status(401).json({ error: 'Authentication required' });
        }

        const response = await axios.post(`${this.apiGatewayUrl}/api/auth/verify`, {
          token,
          projectId: process.env.PROJECT_ID
        });

        if (response.data.success) {
          req.user = response.data.user;
          req.permissions = response.data.permissions;
          next();
        } else {
          return res.status(401).json({ error: 'Invalid token' });
        }
      } catch (error) {
        console.error('Authentication proxy failed:', error);
        return res.status(500).json({ error: 'Authentication failed' });
      }
    };
  }

  // 권한 확인
  authorize(resource, action) {
    return async (req, res, next) => {
      try {
        const response = await axios.post(`${this.apiGatewayUrl}/api/auth/check-permission`, {
          userId: req.user.id,
          resource,
          action,
          projectId: process.env.PROJECT_ID
        });

        if (response.data.hasPermission) {
          next();
        } else {
          return res.status(403).json({ error: 'Insufficient permissions' });
        }
      } catch (error) {
        console.error('Authorization proxy failed:', error);
        return res.status(500).json({ error: 'Authorization failed' });
      }
    };
  }

  extractToken(req) {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }
    return req.cookies?.token || null;
  }
}

module.exports = new AuthProxy();
```

#### **동적 데이터베이스 설정 (projects/project-1/backend/config/database.js)**
```javascript
const axios = require('axios');

class DatabaseConfig {
  constructor() {
    this.databaseServiceUrl = process.env.DATABASE_SERVICE_URL || 'http://database-service:20100';
    this.projectId = process.env.PROJECT_ID;
    this.config = null;
  }

  async getConfig() {
    if (this.config) {
      return this.config;
    }

    try {
      const response = await axios.get(
        `${this.databaseServiceUrl}/api/databases/project/${this.projectId}`
      );

      if (response.data.success) {
        this.config = response.data.database;
        return this.config;
      } else {
        throw new Error('Failed to get database config');
      }
    } catch (error) {
      console.error('Database config fetch failed:', error);
      
      // 폴백 설정 (로컬 개발용)
      this.config = {
        host: process.env.DB_HOST || 'localhost',
        port: process.env.DB_PORT || 5432,
        database: process.env.DB_NAME || 'development',
        username: process.env.DB_USER || 'postgres',
        password: process.env.DB_PASS || 'password',
        dialect: process.env.DB_DIALECT || 'postgres'
      };
      
      return this.config;
    }
  }

  async getSequelizeConfig() {
    const config = await this.getConfig();
    
    return {
      username: config.username,
      password: config.password,
      database: config.database || config.name,
      host: config.host,
      port: config.port,
      dialect: config.type || config.dialect,
      logging: process.env.NODE_ENV === 'development' ? console.log : false,
      pool: {
        max: 10,
        min: 0,
        acquire: 201000,
        idle: 10000
      }
    };
  }
}

module.exports = new DatabaseConfig();
```

## 📊 관리 허브 확장

### 6. **인프라 관리 페이지**

#### **사용자 관리 페이지 (management-hub/frontend/pages/users/index.js)**
```jsx
import React, { useState, useEffect } from 'react';
import Layout from '../../components/layout/Layout';
import UserList from '../../components/users/UserList';
import UserForm from '../../components/users/UserForm';
import RoleManager from '../../components/users/RoleManager';

const UsersManagementPage = () => {
  const [users, setUsers] = useState([]);
  const [roles, setRoles] = useState([]);
  const [projects, setProjects] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [showUserForm, setShowUserForm] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      const [usersRes, rolesRes, projectsRes] = await Promise.all([
        fetch('/api/infrastructure/users'),
        fetch('/api/infrastructure/roles'),
        fetch('/api/infrastructure/projects')
      ]);

      setUsers(await usersRes.json());
      setRoles(await rolesRes.json());
      setProjects(await projectsRes.json());
    } catch (error) {
      console.error('Failed to fetch data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateUser = async (userData) => {
    try {
      const response = await fetch('/api/infrastructure/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });

      if (response.ok) {
        await fetchData();
        setShowUserForm(false);
      }
    } catch (error) {
      console.error('Failed to create user:', error);
    }
  };

  const handleUpdateUserRoles = async (userId, roleIds) => {
    try {
      const response = await fetch(`/api/infrastructure/users/${userId}/roles`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ roleIds })
      });

      if (response.ok) {
        await fetchData();
      }
    } catch (error) {
      console.error('Failed to update user roles:', error);
    }
  };

  const handleAssignProject = async (userId, projectId) => {
    try {
      const response = await fetch(`/api/infrastructure/users/${userId}/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ projectId })
      });

      if (response.ok) {
        await fetchData();
      }
    } catch (error) {
      console.error('Failed to assign project:', error);
    }
  };

  if (loading) {
    return <Layout><div>로딩 중...</div></Layout>;
  }

  return (
    <Layout>
      <div className="users-management">
        <div className="page-header">
          <h1>사용자 관리</h1>
          <button 
            onClick={() => setShowUserForm(true)}
            className="btn-primary"
          >
            새 사용자 추가
          </button>
        </div>

        <div className="management-content">
          <div className="users-section">
            <UserList 
              users={users}
              onSelectUser={setSelectedUser}
              onAssignProject={handleAssignProject}
              projects={projects}
            />
          </div>

          {selectedUser && (
            <div className="user-details">
              <RoleManager
                user={selectedUser}
                roles={roles}
                onUpdateRoles={handleUpdateUserRoles}
              />
            </div>
          )}
        </div>

        {showUserForm && (
          <UserForm
            onSubmit={handleCreateUser}
            onCancel={() => setShowUserForm(false)}
            roles={roles}
          />
        )}
      </div>
    </Layout>
  );
};

export default UsersManagementPage;
```

이 인프라 서비스 시스템을 통해:

1. **중앙집중식 사용자 관리**: 모든 프로젝트가 공통 인증/권한 시스템 사용
2. **동적 데이터베이스 생성**: 프로젝트별 독립적인 데이터베이스 자동 생성
3. **통합 보안**: API 게이트웨이를 통한 일관된 보안 정책 적용
4. **확장 가능한 아키텍처**: 새로운 프로젝트 추가 시 자동으로 인프라 연동
5. **통합 모니터링**: 모든 서비스의 상태와 성능을 중앙에서 관리

특정 부분에 대해 더 자세한 구현이 필요하시면 말씀해 주세요!
