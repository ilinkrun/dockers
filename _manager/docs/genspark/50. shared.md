"""
ì‚¬ìš©ì ê´€ë¦¬ ì„œë²„, ë°ì´í„°ë² ì´ìŠ¤ ì„œë²„ ë“± ê³µìœ  ìì› ê´€ë¦¬ì— í•´ë‹¹í•˜ëŠ” ì„œë²„ êµ¬ì¶•ë„ í•„ìš”í•©ë‹ˆë‹¤.

ì‚¬ìš©ì ê´€ë¦¬ ì„œë²„
- ì‚¬ìš©ì/ì¸ì¦/ê¶Œí•œ ê´€ë¦¬

ë°ì´í„°ë² ì´ìŠ¤ ì„œë²„ ê´€ë¦¬
- í”„ë¡œì íŠ¸ë³„ ë³„ë„ ë””ë¹„ ìƒì„±
"""

ë©‹ì§„ í™•ì¥ ê³„íšì´ë„¤ìš”! ê³µìœ  ìì›ì„ ì¤‘ì•™ì§‘ì¤‘ì‹ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” **ì¸í”„ë¼ ì„œë¹„ìŠ¤ ë ˆì´ì–´**ë¥¼ êµ¬ì¶•í•´ë³´ê² ìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ëª¨ë“  í”„ë¡œì íŠ¸ê°€ ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì‚¬ìš©ì ê´€ë¦¬ì™€ ë°ì´í„°ë² ì´ìŠ¤ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ğŸ—ï¸ ì „ì²´ ì¸í”„ë¼ ì•„í‚¤í…ì²˜

### 1. **ì—…ë°ì´íŠ¸ëœ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ êµ¬ì¡°**

```
workspace/
â”œâ”€â”€ infrastructure/                  # ê³µìœ  ì¸í”„ë¼ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ auth-service/               # ì‚¬ìš©ì ê´€ë¦¬ ì„œë¹„ìŠ¤
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authController.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ userController.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ permissionController.js
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authService.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ userService.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ permissionService.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jwtService.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ emailService.js
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ User.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Role.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Permission.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserRole.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Project.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UserProject.js
â”‚   â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ rbac.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ rateLimiter.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ validation.js
â”‚   â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ users.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ roles.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ projects.js
â”‚   â”‚   â”‚   â”œâ”€â”€ graphql/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth.graphql
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ user.graphql
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ permission.graphql
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ resolvers/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ authResolvers.js
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ userResolvers.js
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ permissionResolvers.js
â”‚   â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ encryption.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ validators.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ constants.js
â”‚   â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ database.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ redis.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ jwt.js
â”‚   â”‚   â”‚   â””â”€â”€ app.js
â”‚   â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ seeds/
â”‚   â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ docker/
â”‚   â”‚   â”‚   â””â”€â”€ Dockerfile
â”‚   â”‚   â”œâ”€â”€ .env.example
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”œâ”€â”€ database-service/           # ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ ì„œë¹„ìŠ¤
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ databaseController.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ migrationController.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ backupController.js
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ databaseService.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ migrationService.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ backupService.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ monitoringService.js
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DatabaseInstance.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Migration.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Backup.js
â”‚   â”‚   â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mysql-template.sql
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ postgresql-template.sql
â”‚   â”‚   â”‚   â”œâ”€â”€ scripts/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ createDatabase.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dropDatabase.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ migrateDatabase.js
â”‚   â”‚   â”‚   â””â”€â”€ app.js
â”‚   â”‚   â”œâ”€â”€ docker/
â”‚   â”‚   â”‚   â””â”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”œâ”€â”€ api-gateway/                # API ê²Œì´íŠ¸ì›¨ì´
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authGateway.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ projectGateway.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ databaseGateway.js
â”‚   â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authentication.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authorization.js
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ logging.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ rateLimit.js
â”‚   â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ proxy.js
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ health.js
â”‚   â”‚   â”‚   â””â”€â”€ app.js
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â”œâ”€â”€ shared-database/            # ê³µìœ  ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
â”‚   â”‚   â”œâ”€â”€ postgresql/
â”‚   â”‚   â”‚   â”œâ”€â”€ init/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ 01-create-auth-db.sql
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ 02-create-management-db.sql
â”‚   â”‚   â”‚   â””â”€â”€ docker-compose.yml
â”‚   â”‚   â””â”€â”€ mysql/
â”‚   â”‚       â”œâ”€â”€ init/
â”‚   â”‚       â””â”€â”€ docker-compose.yml
â”‚   â”œâ”€â”€ monitoring/                 # ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤
â”‚   â”‚   â”œâ”€â”€ prometheus/
â”‚   â”‚   â”œâ”€â”€ grafana/
â”‚   â”‚   â””â”€â”€ elasticsearch/
â”‚   â””â”€â”€ docker-compose.yml         # ì „ì²´ ì¸í”„ë¼ orchestration
â”œâ”€â”€ management-hub/                 # ê¸°ì¡´ ê´€ë¦¬ í—ˆë¸Œ (í™•ì¥)
â”‚   â”œâ”€â”€ frontend/
â”‚   â”‚   â””â”€â”€ pages/
â”‚   â”‚       â”œâ”€â”€ infrastructure/     # ì¸í”„ë¼ ê´€ë¦¬ í˜ì´ì§€
â”‚   â”‚       â”‚   â”œâ”€â”€ auth-service/
â”‚   â”‚       â”‚   â”œâ”€â”€ databases/
â”‚   â”‚       â”‚   â””â”€â”€ monitoring/
â”‚   â”‚       â””â”€â”€ users/              # í†µí•© ì‚¬ìš©ì ê´€ë¦¬
â”‚   â””â”€â”€ backend/
â”‚       â””â”€â”€ src/
â”‚           â”œâ”€â”€ services/
â”‚           â”‚   â”œâ”€â”€ authProxyService.js
â”‚           â”‚   â””â”€â”€ databaseProxyService.js
â”‚           â””â”€â”€ middleware/
â”‚               â””â”€â”€ infraAuth.js
â””â”€â”€ projects/                       # ê°œë³„ í”„ë¡œì íŠ¸ë“¤
    â”œâ”€â”€ project-1/
    â”‚   â”œâ”€â”€ backend/
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ middleware/
    â”‚   â”‚       â”‚   â””â”€â”€ authProxy.js    # ì¸í”„ë¼ ì„œë¹„ìŠ¤ ì—°ë™
    â”‚   â”‚       â””â”€â”€ config/
    â”‚   â”‚           â””â”€â”€ database.js     # ë™ì  DB ì„¤ì •
    â”‚   â””â”€â”€ frontend/
    â”‚       â””â”€â”€ lib/
    â”‚           â””â”€â”€ auth.js             # í†µí•© ì¸ì¦ í´ë¼ì´ì–¸íŠ¸
    â””â”€â”€ project-2/
        â””â”€â”€ [ê°™ì€ êµ¬ì¡°]
```

## ğŸ” ì‚¬ìš©ì ê´€ë¦¬ ì„œë¹„ìŠ¤ (Auth Service)

### 1. **ì‚¬ìš©ì ê´€ë¦¬ ì„œë¹„ìŠ¤ í•µì‹¬ êµ¬í˜„**

#### **ì‚¬ìš©ì ëª¨ë¸ (models/User.js)**
```javascript
const { DataTypes } = require('sequelize');
const bcrypt = require('bcryptjs');

module.exports = (sequelize) => {
  const User = sequelize.define('User', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true
      }
    },
    username: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        len: [3, 50]
      }
    },
    firstName: {
      type: DataTypes.STRING,
      allowNull: false
    },
    lastName: {
      type: DataTypes.STRING,
      allowNull: false
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        len: [8, 100]
      }
    },
    avatar: {
      type: DataTypes.STRING,
      allowNull: true
    },
    isActive: {
      type: DataTypes.BOOLEAN,
      defaultValue: true
    },
    isEmailVerified: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    lastLoginAt: {
      type: DataTypes.DATE,
      allowNull: true
    },
    passwordResetToken: {
      type: DataTypes.STRING,
      allowNull: true
    },
    passwordResetExpires: {
      type: DataTypes.DATE,
      allowNull: true
    },
    emailVerificationToken: {
      type: DataTypes.STRING,
      allowNull: true
    },
    loginAttempts: {
      type: DataTypes.INTEGER,
      defaultValue: 0
    },
    lockUntil: {
      type: DataTypes.DATE,
      allowNull: true
    }
  }, {
    timestamps: true,
    hooks: {
      beforeCreate: async (user) => {
        if (user.password) {
          user.password = await bcrypt.hash(user.password, 12);
        }
      },
      beforeUpdate: async (user) => {
        if (user.changed('password')) {
          user.password = await bcrypt.hash(user.password, 12);
        }
      }
    }
  });

  // ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ
  User.prototype.comparePassword = async function(candidatePassword) {
    return await bcrypt.compare(candidatePassword, this.password);
  };

  User.prototype.isLocked = function() {
    return !!(this.lockUntil && this.lockUntil > Date.now());
  };

  User.prototype.incLoginAttempts = async function() {
    if (this.lockUntil && this.lockUntil < Date.now()) {
      return this.update({
        loginAttempts: 1,
        lockUntil: null
      });
    }

    const updates = { loginAttempts: this.loginAttempts + 1 };
    
    if (this.loginAttempts + 1 >= 5 && !this.isLocked()) {
      updates.lockUntil = Date.now() + 2 * 60 * 60 * 1000; // 2ì‹œê°„ ì ê¸ˆ
    }

    return this.update(updates);
  };

  User.prototype.resetLoginAttempts = async function() {
    return this.update({
      loginAttempts: 0,
      lockUntil: null
    });
  };

  // ì—°ê´€ê´€ê³„
  User.associate = (models) => {
    User.belongsToMany(models.Role, {
      through: models.UserRole,
      foreignKey: 'userId',
      as: 'roles'
    });
    
    User.belongsToMany(models.Project, {
      through: models.UserProject,
      foreignKey: 'userId',
      as: 'projects'
    });
  };

  return User;
};
```

#### **ì—­í•  ë° ê¶Œí•œ ëª¨ë¸ (models/Role.js, models/Permission.js)**
```javascript
// models/Role.js
module.exports = (sequelize, DataTypes) => {
  const Role = sequelize.define('Role', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    description: {
      type: DataTypes.TEXT,
      allowNull: true
    },
    isSystem: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    }
  });

  Role.associate = (models) => {
    Role.belongsToMany(models.User, {
      through: models.UserRole,
      foreignKey: 'roleId',
      as: 'users'
    });
    
    Role.belongsToMany(models.Permission, {
      through: 'RolePermissions',
      foreignKey: 'roleId',
      as: 'permissions'
    });
  };

  return Role;
};

// models/Permission.js
module.exports = (sequelize, DataTypes) => {
  const Permission = sequelize.define('Permission', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    resource: {
      type: DataTypes.STRING,
      allowNull: false
    },
    action: {
      type: DataTypes.ENUM('create', 'read', 'update', 'delete', 'manage'),
      allowNull: false
    },
    scope: {
      type: DataTypes.ENUM('global', 'project', 'own'),
      defaultValue: 'project'
    },
    description: {
      type: DataTypes.TEXT
    }
  });

  Permission.associate = (models) => {
    Permission.belongsToMany(models.Role, {
      through: 'RolePermissions',
      foreignKey: 'permissionId',
      as: 'roles'
    });
  };

  return Permission;
};

// models/Project.js
module.exports = (sequelize, DataTypes) => {
  const Project = sequelize.define('Project', {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    name: {
      type: DataTypes.STRING,
      allowNull: false
    },
    slug: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true
    },
    description: {
      type: DataTypes.TEXT
    },
    status: {
      type: DataTypes.ENUM('active', 'inactive', 'archived'),
      defaultValue: 'active'
    },
    settings: {
      type: DataTypes.JSONB,
      defaultValue: {}
    },
    databaseConfig: {
      type: DataTypes.JSONB,
      allowNull: true
    }
  });

  Project.associate = (models) => {
    Project.belongsToMany(models.User, {
      through: models.UserProject,
      foreignKey: 'projectId',
      as: 'users'
    });
  };

  return Project;
};
```

#### **ì¸ì¦ ì„œë¹„ìŠ¤ (services/authService.js)**
```javascript
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { User, Role, Permission, Project } = require('../models');
const emailService = require('./emailService');
const config = require('../config');

class AuthService {
  // ì‚¬ìš©ì ë“±ë¡
  async register(userData) {
    const { email, username, firstName, lastName, password } = userData;
    
    // ì¤‘ë³µ ê²€ì‚¬
    const existingUser = await User.findOne({
      where: {
        [Op.or]: [{ email }, { username }]
      }
    });

    if (existingUser) {
      throw new Error('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì´ë©”ì¼ ë˜ëŠ” ì‚¬ìš©ìëª…ì…ë‹ˆë‹¤.');
    }

    // ì´ë©”ì¼ ê²€ì¦ í† í° ìƒì„±
    const emailVerificationToken = crypto.randomBytes(32).toString('hex');

    // ì‚¬ìš©ì ìƒì„±
    const user = await User.create({
      email,
      username,
      firstName,
      lastName,
      password,
      emailVerificationToken
    });

    // ê¸°ë³¸ ì—­í•  í• ë‹¹ (USER)
    const userRole = await Role.findOne({ where: { name: 'USER' } });
    if (userRole) {
      await user.addRole(userRole);
    }

    // ì´ë©”ì¼ ê²€ì¦ ë©”ì¼ ë°œì†¡
    await emailService.sendEmailVerification(user.email, emailVerificationToken);

    return {
      user: this.sanitizeUser(user),
      message: 'íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë©”ì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.'
    };
  }

  // ë¡œê·¸ì¸
  async login(email, password, projectId = null) {
    const user = await User.findOne({
      where: { email },
      include: [
        {
          model: Role,
          as: 'roles',
          include: [{
            model: Permission,
            as: 'permissions'
          }]
        },
        {
          model: Project,
          as: 'projects'
        }
      ]
    });

    if (!user) {
      throw new Error('ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }

    // ê³„ì • ì ê¸ˆ í™•ì¸
    if (user.isLocked()) {
      throw new Error('ê³„ì •ì´ ì¼ì‹œì ìœ¼ë¡œ ì ê²¨ìˆìŠµë‹ˆë‹¤. ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
    }

    // ë¹„ë°€ë²ˆí˜¸ í™•ì¸
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      await user.incLoginAttempts();
      throw new Error('ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }

    // ê³„ì • ìƒíƒœ í™•ì¸
    if (!user.isActive) {
      throw new Error('ë¹„í™œì„±í™”ëœ ê³„ì •ì…ë‹ˆë‹¤.');
    }

    // ë¡œê·¸ì¸ ì„±ê³µ ì²˜ë¦¬
    await user.resetLoginAttempts();
    await user.update({ lastLoginAt: new Date() });

    // JWT í† í° ìƒì„±
    const tokens = await this.generateTokens(user, projectId);

    return {
      user: this.sanitizeUser(user),
      tokens,
      permissions: this.extractPermissions(user),
      projects: user.projects
    };
  }

  // JWT í† í° ìƒì„±
  async generateTokens(user, projectId = null) {
    const payload = {
      userId: user.id,
      email: user.email,
      username: user.username,
      projectId,
      roles: user.roles?.map(role => role.name) || []
    };

    const accessToken = jwt.sign(payload, config.jwt.accessSecret, {
      expiresIn: config.jwt.accessExpiresIn
    });

    const refreshToken = jwt.sign(
      { userId: user.id },
      config.jwt.refreshSecret,
      { expiresIn: config.jwt.refreshExpiresIn }
    );

    return { accessToken, refreshToken };
  }

  // í† í° ê²€ì¦
  async verifyToken(token, type = 'access') {
    const secret = type === 'access' ? config.jwt.accessSecret : config.jwt.refreshSecret;
    
    try {
      const decoded = jwt.verify(token, secret);
      const user = await User.findByPk(decoded.userId, {
        include: [
          {
            model: Role,
            as: 'roles',
            include: [{
              model: Permission,
              as: 'permissions'
            }]
          }
        ]
      });

      if (!user || !user.isActive) {
        throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.');
      }

      return { user, decoded };
    } catch (error) {
      throw new Error('í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }
  }

  // ê¶Œí•œ í™•ì¸
  async hasPermission(userId, resource, action, projectId = null, scope = 'project') {
    const user = await User.findByPk(userId, {
      include: [
        {
          model: Role,
          as: 'roles',
          include: [{
            model: Permission,
            as: 'permissions',
            where: {
              resource,
              action: { [Op.in]: [action, 'manage'] }
            }
          }]
        },
        {
          model: Project,
          as: 'projects',
          ...(projectId && { where: { id: projectId } })
        }
      ]
    });

    if (!user) return false;

    // ì‹œìŠ¤í…œ ê´€ë¦¬ìëŠ” ëª¨ë“  ê¶Œí•œ
    const isAdmin = user.roles.some(role => role.name === 'ADMIN');
    if (isAdmin) return true;

    // ê¶Œí•œ í™•ì¸ ë¡œì§
    for (const role of user.roles) {
      for (const permission of role.permissions) {
        if (permission.resource === resource && 
            (permission.action === action || permission.action === 'manage')) {
          
          // ìŠ¤ì½”í”„ í™•ì¸
          if (permission.scope === 'global') return true;
          
          if (permission.scope === 'project' && projectId) {
            const hasProjectAccess = user.projects.some(project => project.id === projectId);
            if (hasProjectAccess) return true;
          }
          
          if (permission.scope === 'own') {
            // ë³¸ì¸ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì ‘ê·¼ (ì¶”ê°€ ë¡œì§ í•„ìš”)
            return true;
          }
        }
      }
    }

    return false;
  }

  // í”„ë¡œì íŠ¸ ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  async hasProjectAccess(userId, projectId) {
    const user = await User.findByPk(userId, {
      include: [{
        model: Project,
        as: 'projects',
        where: { id: projectId }
      }]
    });

    return user && user.projects.length > 0;
  }

  // ì‚¬ìš©ì ì •ë³´ ì •ì œ
  sanitizeUser(user) {
    const { password, passwordResetToken, emailVerificationToken, ...sanitized } = user.toJSON();
    return sanitized;
  }

  // ê¶Œí•œ ì¶”ì¶œ
  extractPermissions(user) {
    const permissions = new Set();
    
    user.roles?.forEach(role => {
      role.permissions?.forEach(permission => {
        permissions.add(`${permission.resource}:${permission.action}:${permission.scope}`);
      });
    });

    return Array.from(permissions);
  }
}

module.exports = new AuthService();
```

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ ì„œë¹„ìŠ¤

### 2. **ë°ì´í„°ë² ì´ìŠ¤ ì„œë¹„ìŠ¤ í•µì‹¬ êµ¬í˜„**

#### **ë°ì´í„°ë² ì´ìŠ¤ ì„œë¹„ìŠ¤ (services/databaseService.js)**
```javascript
const { Client } = require('pg');
const mysql = require('mysql2/promise');
const fs = require('fs-extra');
const path = require('path');
const { DatabaseInstance, Migration } = require('../models');

class DatabaseService {
  constructor() {
    this.adminConnections = {
      postgresql: {
        host: process.env.POSTGRES_HOST || 'localhost',
        port: process.env.POSTGRES_PORT || 5432,
        user: process.env.POSTGRES_ADMIN_USER || 'postgres',
        password: process.env.POSTGRES_ADMIN_PASSWORD,
        database: 'postgres'
      },
      mysql: {
        host: process.env.MYSQL_HOST || 'localhost',
        port: process.env.MYSQL_PORT || 3306,
        user: process.env.MYSQL_ADMIN_USER || 'root',
        password: process.env.MYSQL_ADMIN_PASSWORD,
        database: 'mysql'
      }
    };
  }

  // í”„ë¡œì íŠ¸ ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
  async createProjectDatabase(projectId, config) {
    const { type, name, options = {} } = config;
    
    try {
      let connection;
      let result;

      if (type === 'postgresql') {
        result = await this.createPostgreSQLDatabase(projectId, name, options);
      } else if (type === 'mysql') {
        result = await this.createMySQLDatabase(projectId, name, options);
      } else {
        throw new Error(`ì§€ì›í•˜ì§€ ì•ŠëŠ” ë°ì´í„°ë² ì´ìŠ¤ íƒ€ì…: ${type}`);
      }

      // ë°ì´í„°ë² ì´ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ì •ë³´ ì €ì¥
      const dbInstance = await DatabaseInstance.create({
        projectId,
        name,
        type,
        host: this.adminConnections[type].host,
        port: this.adminConnections[type].port,
        username: result.username,
        password: result.password,
        connectionString: result.connectionString,
        status: 'active',
        config: options
      });

      return {
        success: true,
        database: dbInstance,
        credentials: {
          host: dbInstance.host,
          port: dbInstance.port,
          database: dbInstance.name,
          username: dbInstance.username,
          password: dbInstance.password,
          connectionString: dbInstance.connectionString
        }
      };
    } catch (error) {
      throw new Error(`ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
    }
  }

  // PostgreSQL ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
  async createPostgreSQLDatabase(projectId, dbName, options) {
    const client = new Client(this.adminConnections.postgresql);
    
    try {
      await client.connect();

      // ì‚¬ìš©ì ìƒì„±
      const username = `${projectId}_user`.replace(/-/g, '_');
      const password = this.generatePassword();

      await client.query(`
        CREATE USER "${username}" WITH PASSWORD '${password}'
      `);

      // ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
      await client.query(`
        CREATE DATABASE "${dbName}" 
        OWNER "${username}" 
        ENCODING 'UTF8'
      `);

      // ê¶Œí•œ ë¶€ì—¬
      await client.query(`
        GRANT ALL PRIVILEGES ON DATABASE "${dbName}" TO "${username}"
      `);

      const connectionString = `postgresql://${username}:${password}@${this.adminConnections.postgresql.host}:${this.adminConnections.postgresql.port}/${dbName}`;

      return {
        username,
        password,
        connectionString
      };
    } finally {
      await client.end();
    }
  }

  // MySQL ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
  async createMySQLDatabase(projectId, dbName, options) {
    const connection = await mysql.createConnection(this.adminConnections.mysql);
    
    try {
      // ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
      await connection.execute(`CREATE DATABASE \`${dbName}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci`);

      // ì‚¬ìš©ì ìƒì„±
      const username = `${projectId}_user`.replace(/-/g, '_');
      const password = this.generatePassword();

      await connection.execute(`
        CREATE USER '${username}'@'%' IDENTIFIED BY '${password}'
      `);

      // ê¶Œí•œ ë¶€ì—¬
      await connection.execute(`
        GRANT ALL PRIVILEGES ON \`${dbName}\`.* TO '${username}'@'%'
      `);

      await connection.execute('FLUSH PRIVILEGES');

      const connectionString = `mysql://${username}:${password}@${this.adminConnections.mysql.host}:${this.adminConnections.mysql.port}/${dbName}`;

      return {
        username,
        password,
        connectionString
      };
    } finally {
      await connection.end();
    }
  }

  // ë°ì´í„°ë² ì´ìŠ¤ ì‚­ì œ
  async deleteProjectDatabase(projectId) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    try {
      if (dbInstance.type === 'postgresql') {
        await this.deletePostgreSQLDatabase(dbInstance);
      } else if (dbInstance.type === 'mysql') {
        await this.deleteMySQLDatabase(dbInstance);
      }

      // ìƒíƒœ ì—…ë°ì´íŠ¸
      await dbInstance.update({ status: 'deleted', deletedAt: new Date() });

      return { success: true };
    } catch (error) {
      throw new Error(`ë°ì´í„°ë² ì´ìŠ¤ ì‚­ì œ ì‹¤íŒ¨: ${error.message}`);
    }
  }

  // ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
  async runMigration(projectId, migrationScript) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    try {
      let connection;
      
      if (dbInstance.type === 'postgresql') {
        connection = new Client({
          connectionString: dbInstance.connectionString
        });
        await connection.connect();
        await connection.query(migrationScript);
      } else if (dbInstance.type === 'mysql') {
        connection = await mysql.createConnection({
          host: dbInstance.host,
          port: dbInstance.port,
          user: dbInstance.username,
          password: dbInstance.password,
          database: dbInstance.name
        });
        await connection.execute(migrationScript);
      }

      // ë§ˆì´ê·¸ë ˆì´ì…˜ ì´ë ¥ ì €ì¥
      await Migration.create({
        projectId,
        databaseInstanceId: dbInstance.id,
        script: migrationScript,
        status: 'completed',
        executedAt: new Date()
      });

      return { success: true };
    } catch (error) {
      // ì‹¤íŒ¨í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì´ë ¥ ì €ì¥
      await Migration.create({
        projectId,
        databaseInstanceId: dbInstance.id,
        script: migrationScript,
        status: 'failed',
        error: error.message,
        executedAt: new Date()
      });

      throw new Error(`ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰ ì‹¤íŒ¨: ${error.message}`);
    }
  }

  // ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…
  async backupProjectDatabase(projectId) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    const backupPath = path.join(
      process.env.BACKUP_PATH || '/tmp/backups',
      `${projectId}_${Date.now()}.sql`
    );

    try {
      if (dbInstance.type === 'postgresql') {
        await this.backupPostgreSQL(dbInstance, backupPath);
      } else if (dbInstance.type === 'mysql') {
        await this.backupMySQL(dbInstance, backupPath);
      }

      return {
        success: true,
        backupPath,
        size: (await fs.stat(backupPath)).size
      };
    } catch (error) {
      throw new Error(`ë°±ì—… ì‹¤íŒ¨: ${error.message}`);
    }
  }

  // ë°ì´í„°ë² ì´ìŠ¤ ë³µì›
  async restoreProjectDatabase(projectId, backupPath) {
    const dbInstance = await DatabaseInstance.findOne({
      where: { projectId, status: 'active' }
    });

    if (!dbInstance) {
      throw new Error('ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    if (!await fs.pathExists(backupPath)) {
      throw new Error('ë°±ì—… íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    try {
      if (dbInstance.type === 'postgresql') {
        await this.restorePostgreSQL(dbInstance, backupPath);
      } else if (dbInstance.type === 'mysql') {
        await this.restoreMySQL(dbInstance, backupPath);
      }

      return { success: true };
    } catch (error) {
      throw new Error(`ë³µì› ì‹¤íŒ¨: ${error.message}`);
    }
  }

  // í—¬í¼ ë©”ì„œë“œë“¤
  generatePassword(length = 16) {
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
  }

  async backupPostgreSQL(dbInstance, backupPath) {
    const { spawn } = require('child_process');
    
    return new Promise((resolve, reject) => {
      const pgDump = spawn('pg_dump', [
        '-h', dbInstance.host,
        '-p', dbInstance.port,
        '-U', dbInstance.username,
        '-d', dbInstance.name,
        '-f', backupPath,
        '--verbose'
      ], {
        env: { ...process.env, PGPASSWORD: dbInstance.password }
      });

      pgDump.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`pg_dump ì‹¤í–‰ ì‹¤íŒ¨: exit code ${code}`));
        }
      });
    });
  }

  async backupMySQL(dbInstance, backupPath) {
    const { spawn } = require('child_process');
    
    return new Promise((resolve, reject) => {
      const mysqldump = spawn('mysqldump', [
        '-h', dbInstance.host,
        '-P', dbInstance.port,
        '-u', dbInstance.username,
        `-p${dbInstance.password}`,
        dbInstance.name
      ]);

      const writeStream = fs.createWriteStream(backupPath);
      mysqldump.stdout.pipe(writeStream);

      mysqldump.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`mysqldump ì‹¤í–‰ ì‹¤íŒ¨: exit code ${code}`));
        }
      });
    });
  }
}

module.exports = new DatabaseService();
```

## ğŸŒ API ê²Œì´íŠ¸ì›¨ì´ ë° í†µí•©

### 3. **API ê²Œì´íŠ¸ì›¨ì´ êµ¬í˜„**

#### **ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ (middleware/authentication.js)**
```javascript
const axios = require('axios');
const jwt = require('jsonwebtoken');

class AuthenticationMiddleware {
  constructor() {
    this.authServiceUrl = process.env.AUTH_SERVICE_URL || 'http://auth-service:20100';
  }

  // JWT í† í° ê²€ì¦
  async verifyToken(req, res, next) {
    try {
      const token = this.extractToken(req);
      
      if (!token) {
        return res.status(401).json({
          error: 'Authentication required',
          code: 'NO_TOKEN'
        });
      }

      // Auth ì„œë¹„ìŠ¤ì—ì„œ í† í° ê²€ì¦
      const response = await axios.post(`${this.authServiceUrl}/api/auth/verify`, {
        token
      });

      if (response.data.success) {
        req.user = response.data.user;
        req.permissions = response.data.permissions;
        next();
      } else {
        return res.status(401).json({
          error: 'Invalid token',
          code: 'INVALID_TOKEN'
        });
      }
    } catch (error) {
      console.error('Token verification failed:', error);
      return res.status(401).json({
        error: 'Authentication failed',
        code: 'AUTH_FAILED'
      });
    }
  }

  // ê¶Œí•œ í™•ì¸ ë¯¸ë“¤ì›¨ì–´
  checkPermission(resource, action, scope = 'project') {
    return async (req, res, next) => {
      try {
        if (!req.user) {
          return res.status(401).json({
            error: 'Authentication required',
            code: 'NO_AUTH'
          });
        }

        const projectId = req.params.projectId || req.body.projectId || req.query.projectId;
        
        const response = await axios.post(`${this.authServiceUrl}/api/auth/check-permission`, {
          userId: req.user.id,
          resource,
          action,
          projectId,
          scope
        });

        if (response.data.hasPermission) {
          next();
        } else {
          return res.status(403).json({
            error: 'Insufficient permissions',
            code: 'FORBIDDEN',
            required: `${resource}:${action}:${scope}`
          });
        }
      } catch (error) {
        console.error('Permission check failed:', error);
        return res.status(500).json({
          error: 'Permission check failed',
          code: 'PERMISSION_CHECK_FAILED'
        });
      }
    };
  }

  // í”„ë¡œì íŠ¸ ì ‘ê·¼ ê¶Œí•œ í™•ì¸
  async checkProjectAccess(req, res, next) {
    try {
      const projectId = req.params.projectId || req.body.projectId;
      
      if (!projectId) {
        return res.status(400).json({
          error: 'Project ID required',
          code: 'MISSING_PROJECT_ID'
        });
      }

      const response = await axios.post(`${this.authServiceUrl}/api/auth/check-project-access`, {
        userId: req.user.id,
        projectId
      });

      if (response.data.hasAccess) {
        req.project = response.data.project;
        next();
      } else {
        return res.status(403).json({
          error: 'Project access denied',
          code: 'PROJECT_ACCESS_DENIED'
        });
      }
    } catch (error) {
      console.error('Project access check failed:', error);
      return res.status(500).json({
        error: 'Project access check failed',
        code: 'PROJECT_ACCESS_CHECK_FAILED'
      });
    }
  }

  extractToken(req) {
    const authHeader = req.headers.authorization;
    
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }
    
    return req.cookies?.token || null;
  }
}

module.exports = new AuthenticationMiddleware();
```

## ğŸ³ Docker í†µí•© ì„¤ì •

### 4. **ì¸í”„ë¼ Docker Compose (infrastructure/docker-compose.yml)**

```yaml
version: '3.8'

services:
  # ê³µìœ  ë°ì´í„°ë² ì´ìŠ¤
  shared-postgres:
    image: postgres:15
    container_name: shared-postgres
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - shared_postgres_data:/var/lib/postgresql/data
      - ./shared-database/postgresql/init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - infrastructure

  shared-mysql:
    image: mysql:8.0
    container_name: shared-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}
      MYSQL_DATABASE: management
    volumes:
      - shared_mysql_data:/var/lib/mysql
      - ./shared-database/mysql/init:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
    networks:
      - infrastructure

  # Redis (ì„¸ì…˜, ìºì‹œ)
  redis:
    image: redis:7-alpine
    container_name: shared-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - infrastructure

  # ì‚¬ìš©ì ê´€ë¦¬ ì„œë¹„ìŠ¤
  auth-service:
    build: ./auth-service
    container_name: auth-service
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/auth_db
      REDIS_URL: redis://redis:6379
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
      EMAIL_SERVICE_URL: ${EMAIL_SERVICE_URL}
    depends_on:
      - shared-postgres
      - redis
    ports:
      - "20101:20100"
    volumes:
      - ./auth-service:/app
      - /app/node_modules
    networks:
      - infrastructure

  # ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ ì„œë¹„ìŠ¤
  database-service:
    build: ./database-service
    container_name: database-service
    environment:
      NODE_ENV: production
      POSTGRES_ADMIN_HOST: shared-postgres
      POSTGRES_ADMIN_USER: postgres
      POSTGRES_ADMIN_PASSWORD: ${POSTGRES_PASSWORD}
      MYSQL_ADMIN_HOST: shared-mysql
      MYSQL_ADMIN_USER: root
      MYSQL_ADMIN_PASSWORD: ${MYSQL_PASSWORD}
      BACKUP_PATH: /backups
    depends_on:
      - shared-postgres
      - shared-mysql
    ports:
      - "3002:20100"
    volumes:
      - ./database-service:/app
      - /app/node_modules
      - database_backups:/backups
    networks:
      - infrastructure

  # API ê²Œì´íŠ¸ì›¨ì´
  api-gateway:
    build: ./api-gateway
    container_name: api-gateway
    environment:
      NODE_ENV: production
      AUTH_SERVICE_URL: http://auth-service:20100
      DATABASE_SERVICE_URL: http://database-service:20100
    depends_on:
      - auth-service
      - database-service
    ports:
      - "20100:20100"
    volumes:
      - ./api-gateway:/app
      - /app/node_modules
    networks:
      - infrastructure
      - projects

  # ëª¨ë‹ˆí„°ë§ - Prometheus
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - infrastructure

  # ëª¨ë‹ˆí„°ë§ - Grafana
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
    ports:
      - "3003:20100"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
    networks:
      - infrastructure

volumes:
  shared_postgres_data:
  shared_mysql_data:
  redis_data:
  database_backups:
  prometheus_data:
  grafana_data:

networks:
  infrastructure:
    driver: bridge
  projects:
    driver: bridge
    external: true
```

## ğŸ”§ í”„ë¡œì íŠ¸ ì—°ë™ ì„¤ì •

### 5. **í”„ë¡œì íŠ¸ë³„ ì¸í”„ë¼ ì—°ë™**

#### **í”„ë¡œì íŠ¸ ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ (projects/project-1/backend/middleware/authProxy.js)**
```javascript
const axios = require('axios');

class AuthProxy {
  constructor() {
    this.apiGatewayUrl = process.env.API_GATEWAY_URL || 'http://api-gateway:20100';
  }

  // ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
  authenticate() {
    return async (req, res, next) => {
      try {
        const token = this.extractToken(req);
        
        if (!token) {
          return res.status(401).json({ error: 'Authentication required' });
        }

        const response = await axios.post(`${this.apiGatewayUrl}/api/auth/verify`, {
          token,
          projectId: process.env.PROJECT_ID
        });

        if (response.data.success) {
          req.user = response.data.user;
          req.permissions = response.data.permissions;
          next();
        } else {
          return res.status(401).json({ error: 'Invalid token' });
        }
      } catch (error) {
        console.error('Authentication proxy failed:', error);
        return res.status(500).json({ error: 'Authentication failed' });
      }
    };
  }

  // ê¶Œí•œ í™•ì¸
  authorize(resource, action) {
    return async (req, res, next) => {
      try {
        const response = await axios.post(`${this.apiGatewayUrl}/api/auth/check-permission`, {
          userId: req.user.id,
          resource,
          action,
          projectId: process.env.PROJECT_ID
        });

        if (response.data.hasPermission) {
          next();
        } else {
          return res.status(403).json({ error: 'Insufficient permissions' });
        }
      } catch (error) {
        console.error('Authorization proxy failed:', error);
        return res.status(500).json({ error: 'Authorization failed' });
      }
    };
  }

  extractToken(req) {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }
    return req.cookies?.token || null;
  }
}

module.exports = new AuthProxy();
```

#### **ë™ì  ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • (projects/project-1/backend/config/database.js)**
```javascript
const axios = require('axios');

class DatabaseConfig {
  constructor() {
    this.databaseServiceUrl = process.env.DATABASE_SERVICE_URL || 'http://database-service:20100';
    this.projectId = process.env.PROJECT_ID;
    this.config = null;
  }

  async getConfig() {
    if (this.config) {
      return this.config;
    }

    try {
      const response = await axios.get(
        `${this.databaseServiceUrl}/api/databases/project/${this.projectId}`
      );

      if (response.data.success) {
        this.config = response.data.database;
        return this.config;
      } else {
        throw new Error('Failed to get database config');
      }
    } catch (error) {
      console.error('Database config fetch failed:', error);
      
      // í´ë°± ì„¤ì • (ë¡œì»¬ ê°œë°œìš©)
      this.config = {
        host: process.env.DB_HOST || 'localhost',
        port: process.env.DB_PORT || 5432,
        database: process.env.DB_NAME || 'development',
        username: process.env.DB_USER || 'postgres',
        password: process.env.DB_PASS || 'password',
        dialect: process.env.DB_DIALECT || 'postgres'
      };
      
      return this.config;
    }
  }

  async getSequelizeConfig() {
    const config = await this.getConfig();
    
    return {
      username: config.username,
      password: config.password,
      database: config.database || config.name,
      host: config.host,
      port: config.port,
      dialect: config.type || config.dialect,
      logging: process.env.NODE_ENV === 'development' ? console.log : false,
      pool: {
        max: 10,
        min: 0,
        acquire: 201000,
        idle: 10000
      }
    };
  }
}

module.exports = new DatabaseConfig();
```

## ğŸ“Š ê´€ë¦¬ í—ˆë¸Œ í™•ì¥

### 6. **ì¸í”„ë¼ ê´€ë¦¬ í˜ì´ì§€**

#### **ì‚¬ìš©ì ê´€ë¦¬ í˜ì´ì§€ (management-hub/frontend/pages/users/index.js)**
```jsx
import React, { useState, useEffect } from 'react';
import Layout from '../../components/layout/Layout';
import UserList from '../../components/users/UserList';
import UserForm from '../../components/users/UserForm';
import RoleManager from '../../components/users/RoleManager';

const UsersManagementPage = () => {
  const [users, setUsers] = useState([]);
  const [roles, setRoles] = useState([]);
  const [projects, setProjects] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [showUserForm, setShowUserForm] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      const [usersRes, rolesRes, projectsRes] = await Promise.all([
        fetch('/api/infrastructure/users'),
        fetch('/api/infrastructure/roles'),
        fetch('/api/infrastructure/projects')
      ]);

      setUsers(await usersRes.json());
      setRoles(await rolesRes.json());
      setProjects(await projectsRes.json());
    } catch (error) {
      console.error('Failed to fetch data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateUser = async (userData) => {
    try {
      const response = await fetch('/api/infrastructure/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });

      if (response.ok) {
        await fetchData();
        setShowUserForm(false);
      }
    } catch (error) {
      console.error('Failed to create user:', error);
    }
  };

  const handleUpdateUserRoles = async (userId, roleIds) => {
    try {
      const response = await fetch(`/api/infrastructure/users/${userId}/roles`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ roleIds })
      });

      if (response.ok) {
        await fetchData();
      }
    } catch (error) {
      console.error('Failed to update user roles:', error);
    }
  };

  const handleAssignProject = async (userId, projectId) => {
    try {
      const response = await fetch(`/api/infrastructure/users/${userId}/projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ projectId })
      });

      if (response.ok) {
        await fetchData();
      }
    } catch (error) {
      console.error('Failed to assign project:', error);
    }
  };

  if (loading) {
    return <Layout><div>ë¡œë”© ì¤‘...</div></Layout>;
  }

  return (
    <Layout>
      <div className="users-management">
        <div className="page-header">
          <h1>ì‚¬ìš©ì ê´€ë¦¬</h1>
          <button 
            onClick={() => setShowUserForm(true)}
            className="btn-primary"
          >
            ìƒˆ ì‚¬ìš©ì ì¶”ê°€
          </button>
        </div>

        <div className="management-content">
          <div className="users-section">
            <UserList 
              users={users}
              onSelectUser={setSelectedUser}
              onAssignProject={handleAssignProject}
              projects={projects}
            />
          </div>

          {selectedUser && (
            <div className="user-details">
              <RoleManager
                user={selectedUser}
                roles={roles}
                onUpdateRoles={handleUpdateUserRoles}
              />
            </div>
          )}
        </div>

        {showUserForm && (
          <UserForm
            onSubmit={handleCreateUser}
            onCancel={() => setShowUserForm(false)}
            roles={roles}
          />
        )}
      </div>
    </Layout>
  );
};

export default UsersManagementPage;
```

ì´ ì¸í”„ë¼ ì„œë¹„ìŠ¤ ì‹œìŠ¤í…œì„ í†µí•´:

1. **ì¤‘ì•™ì§‘ì¤‘ì‹ ì‚¬ìš©ì ê´€ë¦¬**: ëª¨ë“  í”„ë¡œì íŠ¸ê°€ ê³µí†µ ì¸ì¦/ê¶Œí•œ ì‹œìŠ¤í…œ ì‚¬ìš©
2. **ë™ì  ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±**: í”„ë¡œì íŠ¸ë³„ ë…ë¦½ì ì¸ ë°ì´í„°ë² ì´ìŠ¤ ìë™ ìƒì„±
3. **í†µí•© ë³´ì•ˆ**: API ê²Œì´íŠ¸ì›¨ì´ë¥¼ í†µí•œ ì¼ê´€ëœ ë³´ì•ˆ ì •ì±… ì ìš©
4. **í™•ì¥ ê°€ëŠ¥í•œ ì•„í‚¤í…ì²˜**: ìƒˆë¡œìš´ í”„ë¡œì íŠ¸ ì¶”ê°€ ì‹œ ìë™ìœ¼ë¡œ ì¸í”„ë¼ ì—°ë™
5. **í†µí•© ëª¨ë‹ˆí„°ë§**: ëª¨ë“  ì„œë¹„ìŠ¤ì˜ ìƒíƒœì™€ ì„±ëŠ¥ì„ ì¤‘ì•™ì—ì„œ ê´€ë¦¬

íŠ¹ì • ë¶€ë¶„ì— ëŒ€í•´ ë” ìì„¸í•œ êµ¬í˜„ì´ í•„ìš”í•˜ì‹œë©´ ë§ì”€í•´ ì£¼ì„¸ìš”!
