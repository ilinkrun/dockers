
"""
도커 환경으로 개발할 때 docker-compose.yml, docker-compose.dev.yml, docker-compose.prod.yml 와 같이 여러개의 docker-compose 별도로 만들고
- 배포 서버들을 구동하면서, 개발 서버들은 코드 변경에 따라 실시간으로 동적 업데이트가 되도록 하려면 어떤 방법을 써야 하는지 구체적으로 알려주세요.
"""

정말 좋은 질문이네요! Docker 환경에서 개발과 프로덕션을 분리하면서도 개발 효율성을 극대화하는 구체적인 방법을 알려드리겠습니다.

## 🐳 Multi-Stage Docker Compose 구조

### 1. **전체 Docker Compose 파일 구조**

```
workspace/
├── docker/
│   ├── docker-compose.yml          # 기본 설정 (공통)
│   ├── docker-compose.dev.yml      # 개발 환경 오버라이드
│   ├── docker-compose.prod.yml     # 프로덕션 환경 오버라이드
│   ├── docker-compose.test.yml     # 테스트 환경 오버라이드
│   └── dockerfiles/
│       ├── backend.dev.Dockerfile  # 개발용 백엔드
│       ├── backend.prod.Dockerfile # 프로덕션용 백엔드
│       ├── frontend.dev.Dockerfile # 개발용 프론트엔드
│       └── frontend.prod.Dockerfile# 프로덕션용 프론트엔드
├── scripts/
│   ├── dev-start.sh               # 개발 환경 시작
│   ├── dev-stop.sh                # 개발 환경 중지
│   ├── prod-start.sh              # 프로덕션 환경 시작
│   ├── prod-stop.sh               # 프로덕션 환경 중지
│   └── hot-reload.sh              # 핫 리로드 스크립트
└── .env.example
```

## 📋 기본 Docker Compose 설정

### 2. **기본 docker-compose.yml (공통 설정)**

```yaml
version: '3.8'

services:
  # 인프라 서비스들 (개발/프로덕션 공통)
  shared-postgres:
    image: postgres:15
    container_name: shared-postgres
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./infrastructure/shared-database/postgresql/init:/docker-entrypoint-initdb.d
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    networks:
      - infrastructure
    restart: unless-stopped

  shared-mysql:
    image: mysql:8.0
    container_name: shared-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}
      MYSQL_DATABASE: management
    volumes:
      - mysql_data:/var/lib/mysql
      - ./infrastructure/shared-database/mysql/init:/docker-entrypoint-initdb.d
    ports:
      - "${MYSQL_PORT:-3306}:3306"
    networks:
      - infrastructure
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: shared-redis
    ports:
      - "${REDIS_PORT:-6379}:6379"
    volumes:
      - redis_data:/data
    networks:
      - infrastructure
    restart: unless-stopped

  # 사용자 관리 서비스
  auth-service:
    container_name: auth-service
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/auth_db
      REDIS_URL: redis://redis:6379
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
    depends_on:
      - shared-postgres
      - redis
    ports:
      - "${AUTH_SERVICE_PORT:-201011}:201000"
    networks:
      - infrastructure

  # 데이터베이스 관리 서비스
  database-service:
    container_name: database-service
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      POSTGRES_ADMIN_HOST: shared-postgres
      POSTGRES_ADMIN_USER: postgres
      POSTGRES_ADMIN_PASSWORD: ${POSTGRES_PASSWORD}
      MYSQL_ADMIN_HOST: shared-mysql
      MYSQL_ADMIN_USER: root
      MYSQL_ADMIN_PASSWORD: ${MYSQL_PASSWORD}
    depends_on:
      - shared-postgres
      - shared-mysql
    ports:
      - "${DATABASE_SERVICE_PORT:-3002}:201000"
    networks:
      - infrastructure

  # API 게이트웨이
  api-gateway:
    container_name: api-gateway
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      AUTH_SERVICE_URL: http://auth-service:201000
      DATABASE_SERVICE_URL: http://database-service:201000
    depends_on:
      - auth-service
      - database-service
    ports:
      - "${API_GATEWAY_PORT:-201000}2010000"
    networks:
      - infrastructure
      - projects

  # 관리 허브 백엔드
  management-backend:
    container_name: management-backend
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/management_db
      API_GATEWAY_URL: http://api-gateway:201000
    depends_on:
      - shared-postgres
      - api-gateway
    ports:
      - "${MANAGEMENT_BACKEND_PORT:-3004}:201000"
    networks:
      - infrastructure

  # 관리 허브 프론트엔드
  management-frontend:
    container_name: management-frontend
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      NEXT_PUBLIC_API_REST_URL: http://localhost:${MANAGEMENT_BACKEND_PORT:-3004}
      NEXT_PUBLIC_GATEWAY_URL: http://localhost:${API_GATEWAY_PORT:-201000}
    depends_on:
      - management-backend
    ports:
      - "${MANAGEMENT_FRONTEND_PORT:-3005}:201000"
    networks:
      - infrastructure

volumes:
  postgres_data:
  mysql_data:
  redis_data:

networks:
  infrastructure:
    driver: bridge
  projects:
    driver: bridge
```

## 🔧 개발 환경 설정

### 3. **docker-compose.dev.yml (개발 환경 오버라이드)**

```yaml
version: '3.8'

services:
  # 인프라 서비스들은 개발 모드로 실행
  auth-service:
    build:
      context: ./infrastructure/auth-service
      dockerfile: ../docker/dockerfiles/backend.dev.Dockerfile
    volumes:
      - ./infrastructure/auth-service:/app
      - /app/node_modules
      - auth_node_modules:/app/node_modules  # named volume for node_modules
    environment:
      NODE_ENV: development
      CHOKIDAR_USEPOLLING: 1  # Windows/macOS에서 파일 변경 감지
      WATCHPACK_POLLING: 1
    command: npm run dev
    restart: unless-stopped

  database-service:
    build:
      context: ./infrastructure/database-service
      dockerfile: ../docker/dockerfiles/backend.dev.Dockerfile
    volumes:
      - ./infrastructure/database-service:/app
      - /app/node_modules
      - db_service_node_modules:/app/node_modules
    environment:
      NODE_ENV: development
      CHOKIDAR_USEPOLLING: 1
    command: npm run dev
    restart: unless-stopped

  api-gateway:
    build:
      context: ./infrastructure/api-gateway
      dockerfile: ../docker/dockerfiles/backend.dev.Dockerfile
    volumes:
      - ./infrastructure/api-gateway:/app
      - /app/node_modules
      - gateway_node_modules:/app/node_modules
    environment:
      NODE_ENV: development
      CHOKIDAR_USEPOLLING: 1
    command: npm run dev
    restart: unless-stopped

  management-backend:
    build:
      context: ./management-hub/backend
      dockerfile: ../../docker/dockerfiles/backend.dev.Dockerfile
    volumes:
      - ./management-hub/backend:/app
      - /app/node_modules
      - mgmt_backend_node_modules:/app/node_modules
    environment:
      NODE_ENV: development
      CHOKIDAR_USEPOLLING: 1
    command: npm run dev
    restart: unless-stopped

  management-frontend:
    build:
      context: ./management-hub/frontend
      dockerfile: ../../docker/dockerfiles/frontend.dev.Dockerfile
    volumes:
      - ./management-hub/frontend:/app
      - /app/node_modules
      - /app/.next  # Next.js 빌드 캐시 제외
      - mgmt_frontend_node_modules:/app/node_modules
    environment:
      NODE_ENV: development
      CHOKIDAR_USEPOLLING: 1
      WATCHPACK_POLLING: 1
      FAST_REFRESH: true
    command: npm run dev
    restart: unless-stopped

  # 개발 도구들
  mailhog:  # 이메일 테스트용
    image: mailhog/mailhog:latest
    container_name: mailhog
    ports:
      - "1025:1025"  # SMTP
      - "8025:8025"  # Web UI
    networks:
      - infrastructure

  # 프로젝트 개발 서버들 (동적 추가)
  project-1-backend:
    build:
      context: ./projects/project-1/backend
      dockerfile: ../../../docker/dockerfiles/backend.dev.Dockerfile
    container_name: project-1-backend
    volumes:
      - ./projects/project-1/backend:/app
      - /app/node_modules
      - project1_backend_node_modules:/app/node_modules
    environment:
      NODE_ENV: development
      PROJECT_ID: project-1
      API_GATEWAY_URL: http://api-gateway:201000
      CHOKIDAR_USEPOLLING: 1
    command: npm run dev
    ports:
      - "4001:4000"
    networks:
      - infrastructure
      - projects
    depends_on:
      - api-gateway
    restart: unless-stopped

  project-1-frontend:
    build:
      context: ./projects/project-1/frontend/nextjs-app
      dockerfile: ../../../../docker/dockerfiles/frontend.dev.Dockerfile
    container_name: project-1-frontend
    volumes:
      - ./projects/project-1/frontend/nextjs-app:/app
      - /app/node_modules
      - /app/.next
      - project1_frontend_node_modules:/app/node_modules
    environment:
      NODE_ENV: development
      NEXT_PUBLIC_API_REST_URL: http://localhost:4001
      CHOKIDAR_USEPOLLING: 1
      WATCHPACK_POLLING: 1
      FAST_REFRESH: true
    command: npm run dev
    ports:
      - "3101:201000"
    networks:
      - projects
    depends_on:
      - project-1-backend
    restart: unless-stopped

volumes:
  # node_modules 전용 볼륨 (성능 향상)
  auth_node_modules:
  db_service_node_modules:
  gateway_node_modules:
  mgmt_backend_node_modules:
  mgmt_frontend_node_modules:
  project1_backend_node_modules:
  project1_frontend_node_modules:
```

## 🚀 프로덕션 환경 설정

### 4. **docker-compose.prod.yml (프로덕션 환경 오버라이드)**

```yaml
version: '3.8'

services:
  # 프로덕션 최적화된 서비스들
  auth-service:
    build:
      context: ./infrastructure/auth-service
      dockerfile: ../docker/dockerfiles/backend.prod.Dockerfile
      args:
        NODE_ENV: production
    environment:
      NODE_ENV: production
    command: npm start
    restart: always
    # 볼륨 마운트 없음 (보안)
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M

  database-service:
    build:
      context: ./infrastructure/database-service
      dockerfile: ../docker/dockerfiles/backend.prod.Dockerfile
    environment:
      NODE_ENV: production
    command: npm start
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M

  api-gateway:
    build:
      context: ./infrastructure/api-gateway  
      dockerfile: ../docker/dockerfiles/backend.prod.Dockerfile
    environment:
      NODE_ENV: production
    command: npm start
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G

  management-backend:
    build:
      context: ./management-hub/backend
      dockerfile: ../../docker/dockerfiles/backend.prod.Dockerfile
    environment:
      NODE_ENV: production
    command: npm start
    restart: always

  management-frontend:
    build:
      context: ./management-hub/frontend
      dockerfile: ../../docker/dockerfiles/frontend.prod.Dockerfile
      args:
        NODE_ENV: production
    environment:
      NODE_ENV: production
    command: npm start
    restart: always

  # Nginx 리버스 프록시 (프로덕션에만)
  nginx:
    image: nginx:alpine
    container_name: nginx-proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./docker/nginx/ssl:/etc/nginx/ssl
    depends_on:
      - management-frontend
      - api-gateway
    networks:
      - infrastructure
    restart: always

  # 모니터링 (프로덕션에만)
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./infrastructure/monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - infrastructure
    restart: always

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
    ports:
      - "3003:201000"
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - infrastructure
    restart: always

volumes:
  prometheus_data:
  grafana_data:
```

## 🔨 개발용 Dockerfile들

### 5. **백엔드 개발용 Dockerfile (dockerfiles/backend.dev.Dockerfile)**

```dockerfile
FROM node:18-alpine

# 개발 도구 설치
RUN apk add --no-cache git python3 make g++

WORKDIR /app

# 패키지 파일 복사 및 설치
COPY package*.json ./
RUN npm ci --include=dev

# nodemon 전역 설치 (개발용)
RUN npm install -g nodemon

# 개발용 사용자 생성 (권한 문제 방지)
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 소스 코드 복사 (개발 시에는 볼륨 마운트로 대체됨)
COPY . .

# 권한 설정
RUN chown -R nextjs:nodejs /app
USER nextjs

# 포트 노출
EXPOSE 201000 4000

# 개발 서버 시작 (hot reload 지원)
CMD ["npm", "run", "dev"]
```

### 6. **프론트엔드 개발용 Dockerfile (dockerfiles/frontend.dev.Dockerfile)**

```dockerfile
FROM node:18-alpine

# 개발 도구 설치
RUN apk add --no-cache git python3 make g++

WORKDIR /app

# 패키지 파일 복사 및 설치
COPY package*.json ./
RUN npm ci --include=dev

# Next.js 캐시 디렉토리 생성
RUN mkdir -p .next

# 개발용 사용자 생성
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# 소스 코드 복사
COPY . .

# 권한 설정
RUN chown -R nextjs:nodejs /app
USER nextjs

# 포트 노출
EXPOSE 201000

# Next.js 개발 서버 시작 (Fast Refresh 지원)
CMD ["npm", "run", "dev"]
```

## 🚀 프로덕션용 Dockerfile들

### 7. **백엔드 프로덕션용 Dockerfile (dockerfiles/backend.prod.Dockerfile)**

```dockerfile
# Multi-stage build
FROM node:18-alpine AS builder

WORKDIR /app

# 패키지 파일 복사 및 프로덕션 의존성 설치
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# 소스 코드 복사
COPY . .

# 프로덕션 단계
FROM node:18-alpine AS runner

# 보안을 위한 non-root 사용자 생성
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

WORKDIR /app

# 빌드된 앱과 의존성 복사
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app .

USER nodejs

EXPOSE 201000

# 프로덕션 모드로 실행
CMD ["npm", "start"]
```

### 8. **프론트엔드 프로덕션용 Dockerfile (dockerfiles/frontend.prod.Dockerfile)**

```dockerfile
# Multi-stage build
FROM node:18-alpine AS dependencies

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# 빌드 단계
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .

# Next.js 빌드
RUN npm run build

# 런타임 단계
FROM node:18-alpine AS runner

# 보안을 위한 non-root 사용자
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

WORKDIR /app

# 필요한 파일들만 복사
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 201000

ENV PORT 201000

CMD ["node", "server.js"]
```

## 🎛️ 스크립트 자동화

### 9. **개발 환경 시작 스크립트 (scripts/dev-start.sh)**

```bash
#!/bin/bash

set -e

echo "🚀 개발 환경을 시작합니다..."

# 환경 변수 파일 확인
if [ ! -f .env ]; then
    echo "⚠️  .env 파일이 없습니다. .env.example을 복사해주세요."
    cp .env.example .env
    echo "📝 .env 파일이 생성되었습니다. 필요한 설정을 수정해주세요."
fi

# Docker 네트워크 생성 (존재하지 않는 경우)
docker network create projects 2>/dev/null || echo "📡 projects 네트워크가 이미 존재합니다."

# 개발 환경 시작
echo "🔧 인프라 서비스들을 시작합니다..."
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.dev.yml \
  up -d shared-postgres shared-mysql redis

echo "⏳ 데이터베이스가 준비될 때까지 대기합니다..."
sleep 10

echo "🛠️  인프라 서비스들을 시작합니다..."
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.dev.yml \
  up -d auth-service database-service api-gateway

echo "⏳ 인프라 서비스가 준비될 때까지 대기합니다..."
sleep 15

echo "📊 관리 허브를 시작합니다..."
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.dev.yml \
  up -d management-backend management-frontend

echo "🎯 프로젝트 개발 서버들을 시작합니다..."
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.dev.yml \
  up -d project-1-backend project-1-frontend

echo "✅ 개발 환경이 성공적으로 시작되었습니다!"
echo ""
echo "📋 서비스 접속 정보:"
echo "   🌐 Management Hub: http://localhost:3005"
echo "   🔐 API Gateway: http://localhost:201000"
echo "   👤 Auth Service: http://localhost:201011"
echo "   🗄️  Database Service: http://localhost:3002"
echo "   📧 MailHog: http://localhost:8025"
echo "   🎯 Project 1 Frontend: http://localhost:3101"
echo "   🔧 Project 1 Backend: http://localhost:4001"
echo ""
echo "📊 로그 확인: docker-compose -f docker/docker-compose.yml -f docker/docker-compose.dev.yml logs -f [service-name]"
echo "🛑 중지: ./scripts/dev-stop.sh"
```

### 10. **프로덕션 환경 시작 스크립트 (scripts/prod-start.sh)**

```bash
#!/bin/bash

set -e

echo "🚀 프로덕션 환경을 시작합니다..."

# 환경 변수 확인
if [ ! -f .env.prod ]; then
    echo "❌ .env.prod 파일이 필요합니다."
    exit 1
fi

# 프로덕션 이미지 빌드
echo "🔨 프로덕션 이미지를 빌드합니다..."
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.prod.yml \
  --env-file .env.prod \
  build --no-cache

# 프로덕션 환경 시작
echo "🏃 프로덕션 서비스들을 시작합니다..."
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.prod.yml \
  --env-file .env.prod \
  up -d

echo "✅ 프로덕션 환경이 시작되었습니다!"
echo "🌐 서비스 접속: https://your-domain.com"
```

### 11. **핫 리로드 최적화 스크립트 (scripts/hot-reload.sh)**

```bash
#!/bin/bash

# 특정 프로젝트의 핫 리로드 최적화
PROJECT_NAME=${1:-"project-1"}

echo "🔥 $PROJECT_NAME 핫 리로드를 최적화합니다..."

# Node.js 프로세스 재시작 (백엔드)
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.dev.yml \
  exec ${PROJECT_NAME}-backend npm run restart

# Next.js Fast Refresh 확인 (프론트엔드)
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.dev.yml \
  exec ${PROJECT_NAME}-frontend npm run dev:refresh

echo "✅ 핫 리로드가 최적화되었습니다!"
```

## 🔧 개발 최적화 설정

### 12. **package.json 개발 스크립트**

```json
{
  "scripts": {
    "dev": "nodemon --watch src --ext js,json,graphql --exec node src/app.js",
    "dev:debug": "nodemon --inspect=0.0.0.0:9229 --watch src --ext js,json,graphql --exec node src/app.js",
    "dev:refresh": "kill -USR2 $(pgrep -f 'node.*src/app.js') 2>/dev/null || echo 'Process not found'",
    "start": "node src/app.js",
    "restart": "npm run dev"
  },
  "nodemonConfig": {
    "watch": ["src"],
    "ext": "js,json,graphql",
    "ignore": ["node_modules", "*.test.js"],
    "delay": 1000,
    "env": {
      "NODE_ENV": "development"
    }
  }
}
```

### 13. **Next.js 개발 설정 (next.config.js)**

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  // 개발 환경에서만 Fast Refresh 활성화
  ...(process.env.NODE_ENV === 'development' && {
    experimental: {
      fastRefresh: true,
    },
    webpack: (config, { dev, isServer }) => {
      if (dev && !isServer) {
        // 핫 리로드 최적화
        config.watchOptions = {
          poll: 1000,
          aggregateTimeout: 300,
        };
      }
      return config;
    },
  }),

  // 프로덕션 최적화
  ...(process.env.NODE_ENV === 'production' && {
    output: 'standalone',
    compress: true,
    poweredByHeader: false,
  }),

  env: {
    CUSTOM_KEY: process.env.CUSTOM_KEY,
  },
};

module.exports = nextConfig;
```

### 14. **환경별 실행 명령어**

```bash
# 개발 환경
./scripts/dev-start.sh

# 특정 서비스만 재시작
docker-compose -f docker/docker-compose.yml -f docker/docker-compose.dev.yml restart project-1-backend

# 로그 실시간 확인
docker-compose -f docker/docker-compose.yml -f docker/docker-compose.dev.yml logs -f project-1-backend

# 프로덕션 환경
./scripts/prod-start.sh

# 개발 환경 중지
./scripts/dev-stop.sh

# 프로덕션 환경 중지
./scripts/prod-stop.sh
```

## 🎯 핵심 포인트

### **개발 환경에서의 핫 리로드 보장:**

1. **볼륨 마운팅**: 소스 코드를 컨테이너에 마운트
2. **Named Volumes**: `node_modules`를 별도 볼륨으로 분리 (성능 향상)
3. **파일 감시**: `CHOKIDAR_USEPOLLING=1`로 파일 변경 감지
4. **개발 도구**: nodemon, Next.js Fast Refresh 활용
5. **단계별 시작**: 의존성 순서에 따른 서비스 시작

### **프로덕션 환경에서의 최적화:**

1. **Multi-stage Build**: 빌드와 런타임 분리
2. **보안 강화**: non-root 사용자, 불필요한 패키지 제거
3. **리소스 제한**: CPU, 메모리 사용량 제한
4. **모니터링**: Prometheus, Grafana 추가
5. **로드 밸런싱**: Nginx 리버스 프록시

이 구조를 사용하면 개발 시에는 코드 변경이 즉시 반영되면서도, 프로덕션에서는 최적화된 환경을 유지할 수 있습니다!

===

"""
docker-compose 파일에서 동일한 디렉토리에 있지 않은 .env 의 변수를 사용할 수 있나요?
예를 들어 아래와 같다면

├── docker/                           # Docker 관련 파일들
│   ├── docker-compose.yml
│   ├── docker-compose.dev.yml
│   ├── docker-compose.prod.yml

...

├── environments/                    # 환경별 설정
│   ├── development/.env
│   ├── staging/
│   └── production/.env
"""

네! 동일한 디렉토리에 있지 않은 `.env` 파일의 변수를 사용할 수 있습니다. 여러 가지 방법이 있어서 상황에 맞게 선택할 수 있어요.

## 🎯 방법별 상세 설명

### 1. **--env-file 옵션 사용 (가장 추천)**

#### **명령어에서 직접 지정:**
```bash
# 개발 환경
docker-compose -f docker/docker-compose.yml -f docker/docker-compose.dev.yml --env-file environments/development/.env up -d

# 프로덕션 환경
docker-compose -f docker/docker-compose.yml -f docker/docker-compose.prod.yml --env-file environments/production/.env up -d

# 여러 .env 파일 사용 (순서대로 적용됨)
docker-compose -f docker/docker-compose.yml -f docker/docker-compose.dev.yml --env-file environments/common/.env --env-file environments/development/.env up -d
```

### 2. **스크립트로 자동화 (최고 추천)**

#### **개발 환경 시작 스크립트 (scripts/dev-start.sh)**
```bash
#!/bin/bash

set -e

echo "🚀 개발 환경을 시작합니다..."

# 작업 디렉토리를 프로젝트 루트로 변경
cd "$(dirname "$0")/.."

# 환경 변수 파일 확인
ENV_FILE="environments/development/.env"
if [ ! -f "$ENV_FILE" ]; then
    echo "❌ $ENV_FILE 파일이 없습니다."
    exit 1
fi

echo "📁 환경 변수 로드: $ENV_FILE"

# Docker Compose 실행
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.dev.yml \
  --env-file "$ENV_FILE" \
  up -d

echo "✅ 개발 환경이 시작되었습니다!"
```

#### **프로덕션 환경 시작 스크립트 (scripts/prod-start.sh)**
```bash
#!/bin/bash

set -e

echo "🚀 프로덕션 환경을 시작합니다..."

cd "$(dirname "$0")/.."

ENV_FILE="environments/production/.env"
if [ ! -f "$ENV_FILE" ]; then
    echo "❌ $ENV_FILE 파일이 없습니다."
    exit 1
fi

echo "📁 환경 변수 로드: $ENV_FILE"

# 프로덕션 이미지 빌드
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.prod.yml \
  --env-file "$ENV_FILE" \
  build --no-cache

# 프로덕션 환경 시작
docker-compose \
  -f docker/docker-compose.yml \
  -f docker/docker-compose.prod.yml \
  --env-file "$ENV_FILE" \
  up -d

echo "✅ 프로덕션 환경이 시작되었습니다!"
```

### 3. **환경별 .env 파일 구조**

#### **공통 환경 변수 (environments/common/.env)**
```bash
# 공통 설정
COMPOSE_PROJECT_NAME=workspace
COMPOSE_FILE=docker/docker-compose.yml

# 데이터베이스 공통 설정
POSTGRES_USER=postgres
MYSQL_USER=root

# Redis 설정
REDIS_PORT=6379

# JWT 공통 설정 (실제로는 환경별로 다르게 설정해야 함)
JWT_ACCESS_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d
```

#### **개발 환경 (environments/development/.env)**
```bash
# 환경 식별
NODE_ENV=development
ENVIRONMENT=development

# 포트 설정 (개발용)
API_GATEWAY_PORT=201000
AUTH_SERVICE_PORT=201011
DATABASE_SERVICE_PORT=3002
MANAGEMENT_BACKEND_PORT=3004
MANAGEMENT_FRONTEND_PORT=3005

# 데이터베이스 설정 (개발용)
POSTGRES_PASSWORD=dev_password
POSTGRES_PORT=5432
MYSQL_PASSWORD=dev_password
MYSQL_PORT=3306

# JWT 시크릿 (개발용 - 간단한 값)
JWT_ACCESS_SECRET=dev_access_secret_key_12345
JWT_REFRESH_SECRET=dev_refresh_secret_key_12345

# 외부 서비스 (개발용)
EMAIL_SERVICE_URL=http://mailhog:1025
REDIS_URL=redis://redis:6379

# 개발 도구
CHOKIDAR_USEPOLLING=1
WATCHPACK_POLLING=1
FAST_REFRESH=true

# 로깅
LOG_LEVEL=debug
```

#### **프로덕션 환경 (environments/production/.env)**
```bash
# 환경 식별
NODE_ENV=production
ENVIRONMENT=production

# 포트 설정 (프로덕션용 - 보통 내부 포트만)
API_GATEWAY_PORT=201000
AUTH_SERVICE_PORT=201011
DATABASE_SERVICE_PORT=3002
MANAGEMENT_BACKEND_PORT=3004
MANAGEMENT_FRONTEND_PORT=3005

# 데이터베이스 설정 (프로덕션용 - 강력한 패스워드)
POSTGRES_PASSWORD=super_secure_postgres_password_2024!
POSTGRES_PORT=5432
MYSQL_PASSWORD=super_secure_mysql_password_2024!
MYSQL_PORT=3306

# JWT 시크릿 (프로덕션용 - 복잡한 값)
JWT_ACCESS_SECRET=prod_access_very_long_and_complex_secret_key_with_special_chars_!@#$%^&*()
JWT_REFRESH_SECRET=prod_refresh_very_long_and_complex_secret_key_with_special_chars_!@#$%^&*()

# 외부 서비스 (프로덕션용)
EMAIL_SERVICE_URL=smtp://your-smtp-server:587
REDIS_URL=redis://redis:6379

# 보안 설정
CORS_ORIGIN=https://your-domain.com
SECURE_COOKIES=true
HTTPS_ONLY=true

# 모니터링
GRAFANA_PASSWORD=secure_grafana_password_2024!
PROMETHEUS_RETENTION=30d

# 로깅
LOG_LEVEL=info
LOG_FILE=/var/log/app.log
```

### 4. **고급 환경 관리 스크립트**

#### **통합 환경 관리 스크립트 (scripts/env-manager.sh)**
```bash
#!/bin/bash

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 함수들
print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# 사용법 출력
usage() {
    echo "사용법: $0 [ENVIRONMENT] [ACTION]"
    echo ""
    echo "ENVIRONMENT:"
    echo "  dev, development    개발 환경"
    echo "  staging            스테이징 환경"
    echo "  prod, production   프로덕션 환경"
    echo ""
    echo "ACTION:"
    echo "  up                 서비스 시작"
    echo "  down               서비스 중지"
    echo "  restart            서비스 재시작"
    echo "  logs               로그 확인"
    echo "  ps                 서비스 상태 확인"
    echo "  build             이미지 빌드"
    echo ""
    echo "예시:"
    echo "  $0 dev up          개발 환경 시작"
    echo "  $0 prod build      프로덕션 이미지 빌드"
    echo "  $0 staging logs    스테이징 로그 확인"
}

# 환경 설정
setup_environment() {
    local env=$1
    
    case $env in
        "dev"|"development")
            ENV_NAME="development"
            COMPOSE_FILES="-f docker/docker-compose.yml -f docker/docker-compose.dev.yml"
            ;;
        "staging")
            ENV_NAME="staging"
            COMPOSE_FILES="-f docker/docker-compose.yml -f docker/docker-compose.staging.yml"
            ;;
        "prod"|"production")
            ENV_NAME="production"
            COMPOSE_FILES="-f docker/docker-compose.yml -f docker/docker-compose.prod.yml"
            ;;
        *)
            print_error "지원하지 않는 환경: $env"
            usage
            exit 1
            ;;
    esac
    
    ENV_FILE="environments/${ENV_NAME}/.env"
    
    if [ ! -f "$ENV_FILE" ]; then
        print_error "환경 파일이 없습니다: $ENV_FILE"
        exit 1
    fi
    
    print_info "환경: $ENV_NAME"
    print_info "설정 파일: $ENV_FILE"
}

# Docker Compose 명령 실행
run_docker_compose() {
    local action=$1
    shift
    
    print_info "Docker Compose 실행: $action"
    
    docker-compose $COMPOSE_FILES --env-file "$ENV_FILE" $action "$@"
}

# 메인 로직
main() {
    if [ $# -lt 2 ]; then
        usage
        exit 1
    fi
    
    local environment=$1
    local action=$2
    shift 2
    
    # 프로젝트 루트로 이동
    cd "$(dirname "$0")/.."
    
    # 환경 설정
    setup_environment "$environment"
    
    case $action in
        "up")
            print_info "서비스를 시작합니다..."
            run_docker_compose up -d "$@"
            print_success "서비스가 시작되었습니다!"
            ;;
        "down")
            print_info "서비스를 중지합니다..."
            run_docker_compose down "$@"
            print_success "서비스가 중지되었습니다!"
            ;;
        "restart")
            print_info "서비스를 재시작합니다..."
            run_docker_compose restart "$@"
            print_success "서비스가 재시작되었습니다!"
            ;;
        "logs")
            print_info "로그를 확인합니다..."
            run_docker_compose logs -f "$@"
            ;;
        "ps")
            print_info "서비스 상태를 확인합니다..."
            run_docker_compose ps "$@"
            ;;
        "build")
            print_info "이미지를 빌드합니다..."
            run_docker_compose build --no-cache "$@"
            print_success "이미지 빌드가 완료되었습니다!"
            ;;
        "exec")
            if [ $# -lt 1 ]; then
                print_error "서비스 이름이 필요합니다."
                echo "사용법: $0 $environment exec [SERVICE] [COMMAND]"
                exit 1
            fi
            run_docker_compose exec "$@"
            ;;
        *)
            print_error "지원하지 않는 액션: $action"
            usage
            exit 1
            ;;
    esac
}

# 스크립트 실행
main "$@"
```

### 5. **사용 예시**

#### **개발 환경 관리:**
```bash
# 권한 부여 (최초 1회)
chmod +x scripts/env-manager.sh

# 개발 환경 시작
./scripts/env-manager.sh dev up

# 특정 서비스만 시작
./scripts/env-manager.sh dev up auth-service management-frontend

# 개발 환경 로그 확인
./scripts/env-manager.sh dev logs

# 특정 서비스 로그 확인
./scripts/env-manager.sh dev logs auth-service

# 개발 환경 중지
./scripts/env-manager.sh dev down
```

#### **프로덕션 환경 관리:**
```bash
# 프로덕션 이미지 빌드
./scripts/env-manager.sh prod build

# 프로덕션 환경 시작
./scripts/env-manager.sh prod up

# 프로덕션 서비스 상태 확인
./scripts/env-manager.sh prod ps

# 프로덕션 환경 로그 확인 (에러만)
./scripts/env-manager.sh prod logs --tail=100 | grep ERROR
```

### 6. **Docker Compose 파일에서 환경 변수 사용 예시**

#### **docker-compose.yml에서의 활용:**
```yaml
version: '3.8'

services:
  auth-service:
    container_name: auth-service
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/auth_db
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
    ports:
      - "${AUTH_SERVICE_PORT:-201011}:201000"
    
  management-frontend:
    container_name: management-frontend
    environment:
      NODE_ENV: ${NODE_ENV:-development}
      NEXT_PUBLIC_API_REST_URL: ${NEXT_PUBLIC_API_REST_URL:-http://localhost:3004}
      NEXT_PUBLIC_GATEWAY_URL: ${NEXT_PUBLIC_GATEWAY_URL:-http://localhost:201000}
    ports:
      - "${MANAGEMENT_FRONTEND_PORT:-3005}:201000"
```

## 🎯 추천하는 방법

**가장 실용적인 조합:**
1. **환경별 .env 파일** 구조화
2. **통합 관리 스크립트** 사용
3. **--env-file 옵션** 활용

이 방법을 사용하면:
- ✅ 환경별 설정이 명확히 분리됨
- ✅ 한 번의 명령으로 쉽게 환경 전환 가능
- ✅ 실수 방지 (잘못된 환경에 배포하는 것 등)
- ✅ 팀원들이 일관된 방식으로 환경 관리 가능

특히 `scripts/env-manager.sh` 스크립트를 사용하면 복잡한 Docker Compose 명령을 기억할 필요 없이 간단하게 환경을 관리할 수 있어요!

===

"""
staging 은 어떤 단계인가요? staging이 development, production과의 차별점은?
"""

정말 좋은 질문이네요! **Staging** 환경은 소프트웨어 개발에서 매우 중요한 단계인데, 많은 개발자들이 헷갈려하는 부분이에요. 각 환경의 목적과 차이점을 명확히 설명해드리겠습니다.

## 🎯 개발 단계별 환경 개요

### **환경별 역할과 목적**

```
개발자 로컬 → Development → Staging → Production
    ↓              ↓           ↓         ↓
  개인 개발    →  통합 개발  →  실제 테스트 → 실제 서비스
```

## 🔧 Development 환경

### **목적:**
- **개발자들의 협업 공간**
- **기능 통합 및 초기 테스트**
- **빠른 개발 사이클 지원**

### **특징:**
```yaml
# environments/development/.env
NODE_ENV=development
ENVIRONMENT=development

# 개발 편의성 우선
LOG_LEVEL=debug
CHOKIDAR_USEPOLLING=1  # 핫 리로드
FAST_REFRESH=true

# 약한 보안 (개발 편의성)
JWT_ACCESS_SECRET=simple_dev_secret
CORS_ORIGIN=*
SECURE_COOKIES=false

# 개발용 서비스
EMAIL_SERVICE_URL=http://mailhog:1025  # 가짜 이메일
DATABASE_URL=postgresql://postgres:dev_password@localhost:5432/dev_db

# 외부 API 모킹
PAYMENT_SERVICE_URL=http://mock-payment:201000
```

### **사용 사례:**
- 개발된 기능들을 통합하여 테스트
- 다른 개발자의 코드와 충돌 확인
- 기본적인 기능 동작 확인
- API 연동 테스트

## 🧪 Staging 환경

### **목적:**
- **Production 환경의 완벽한 복제품**
- **실제 운영 환경에서의 최종 테스트**
- **배포 전 마지막 검증 단계**

### **특징:**
```yaml
# environments/staging/.env
NODE_ENV=production  # 주목! production 모드로 실행
ENVIRONMENT=staging

# Production과 동일한 설정 (단, 데이터만 다름)
LOG_LEVEL=info
SECURE_COOKIES=true
HTTPS_ONLY=true

# Production급 보안
JWT_ACCESS_SECRET=staging_very_complex_secret_key_!@#$%
CORS_ORIGIN=https://staging.yourdomain.com

# 실제 서비스와 유사한 외부 연동 (테스트 계정)
EMAIL_SERVICE_URL=smtp://test-smtp.yourdomain.com:587
PAYMENT_SERVICE_URL=https://sandbox.payment-provider.com

# Production과 동일한 데이터베이스 구조 (다른 데이터)
DATABASE_URL=postgresql://postgres:staging_password@staging-db:5432/staging_db

# Production 미러링
REDIS_URL=redis://staging-redis:6379
MONITORING_ENABLED=true
```

### **핵심 차별점:**
1. **Production과 동일한 인프라 구조**
2. **실제 외부 서비스 연동 (테스트 계정)**
3. **Production 레벨의 보안 설정**
4. **실제 배포 프로세스 검증**

## 🚀 Production 환경

### **목적:**
- **실제 사용자에게 서비스 제공**
- **최고 수준의 안정성과 성능**
- **실제 비즈니스 데이터 처리**

### **특징:**
```yaml
# environments/production/.env
NODE_ENV=production
ENVIRONMENT=production

# 최적화된 성능 설정
LOG_LEVEL=warn
CACHE_ENABLED=true
COMPRESSION_ENABLED=true

# 최고 수준의 보안
JWT_ACCESS_SECRET=production_ultra_secure_secret_key_with_rotation
CORS_ORIGIN=https://yourdomain.com
SECURE_COOKIES=true
HTTPS_ONLY=true
HSTS_ENABLED=true

# 실제 외부 서비스
EMAIL_SERVICE_URL=smtp://smtp.yourdomain.com:587
PAYMENT_SERVICE_URL=https://api.payment-provider.com

# 실제 데이터베이스
DATABASE_URL=postgresql://postgres:ultra_secure_password@prod-db:5432/production_db

# 고급 모니터링
MONITORING_ENABLED=true
METRICS_ENABLED=true
ALERTING_ENABLED=true
```

## 📊 환경별 상세 비교표

| 항목 | Development | Staging | Production |
|------|-------------|---------|------------|
| **목적** | 개발/통합 테스트 | 최종 검증 | 실제 서비스 |
| **데이터** | 가짜/테스트 데이터 | 실제와 유사한 테스트 데이터 | 실제 사용자 데이터 |
| **외부 API** | Mock/가짜 서비스 | Sandbox/테스트 계정 | 실제 서비스 |
| **보안 수준** | 낮음 (편의성 우선) | 높음 (Production 수준) | 최고 |
| **성능** | 낮음 (개발 도구 많음) | 높음 (Production 유사) | 최고 |
| **모니터링** | 기본적 | 상세함 | 완전함 |
| **배포 빈도** | 매우 높음 (수시로) | 보통 (릴리스 전) | 낮음 (안정적일 때만) |
| **다운타임** | 상관없음 | 어느 정도 허용 | 절대 안됨 |

## 🔄 실제 개발 워크플로우

### **일반적인 개발 프로세스:**

```
1. 로컬 개발
   ↓
2. Development 환경에 배포
   ├─ 기능 통합 테스트
   ├─ 다른 개발자와의 협업 확인
   └─ 기본적인 QA
   ↓
3. Staging 환경에 배포
   ├─ Production 환경 시뮬레이션
   ├─ 실제 외부 서비스 연동 테스트
   ├─ 성능 테스트
   ├─ 보안 테스트
   ├─ 사용자 수용 테스트 (UAT)
   └─ 최종 QA 검증
   ↓
4. Production 환경에 배포
   └─ 실제 서비스 시작
```

## 🏗️ Staging 환경 구체적 구현

### **docker-compose.staging.yml**
```yaml
version: '3.8'

services:
  # Staging은 Production과 거의 동일하지만 리소스는 약간 적게
  auth-service:
    build:
      context: ./infrastructure/auth-service
      dockerfile: ../docker/dockerfiles/backend.prod.Dockerfile  # Production 빌드 사용
    environment:
      NODE_ENV: production  # 중요: production 모드
      ENVIRONMENT: staging
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.25'      # Production보다 적은 리소스
          memory: 256M

  management-frontend:
    build:
      context: ./management-hub/frontend
      dockerfile: ../../docker/dockerfiles/frontend.prod.Dockerfile
    environment:
      NODE_ENV: production
      ENVIRONMENT: staging
      # Staging 전용 URL들
      NEXT_PUBLIC_API_REST_URL: https://staging-api.yourdomain.com
      NEXT_PUBLIC_GATEWAY_URL: https://staging.yourdomain.com
    restart: always

  # Staging 전용 데이터베이스 (Production 미러링)
  staging-postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: staging_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - staging_postgres_data:/var/lib/postgresql/data
      # Production과 동일한 초기화 스크립트
      - ./infrastructure/shared-database/postgresql/init:/docker-entrypoint-initdb.d
    restart: always

  # 모니터링 (Production과 동일)
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./infrastructure/monitoring/prometheus/staging.yml:/etc/prometheus/prometheus.yml
    restart: always

  # 실제 외부 서비스 연동 테스트용
  external-service-proxy:
    image: nginx:alpine
    volumes:
      - ./docker/nginx/staging-proxy.conf:/etc/nginx/nginx.conf
    ports:
      - "443:443"
    restart: always

volumes:
  staging_postgres_data:
```

## 🧑‍💼 각 환경에서의 테스트 시나리오

### **Development 환경에서:**
```javascript
// 개발 환경 테스트 - 기본 기능 확인
describe('Development Environment Tests', () => {
  it('should connect to mock email service', async () => {
    // MailHog 같은 개발용 이메일 서비스 테스트
    expect(emailService.provider).toBe('mailhog');
  });

  it('should use development database', async () => {
    expect(process.env.DATABASE_URL).toContain('dev_db');
  });

  it('should allow CORS from anywhere', async () => {
    expect(corsConfig.origin).toBe('*');
  });
});
```

### **Staging 환경에서:**
```javascript
// Staging 환경 테스트 - Production 시뮬레이션
describe('Staging Environment Tests', () => {
  it('should connect to real SMTP service', async () => {
    // 실제 SMTP 서비스 연동 테스트
    const result = await emailService.sendTestEmail();
    expect(result.provider).toBe('smtp');
    expect(result.success).toBe(true);
  });

  it('should use production-like database', async () => {
    expect(process.env.DATABASE_URL).toContain('staging_db');
    expect(process.env.NODE_ENV).toBe('production');
  });

  it('should have strict CORS policy', async () => {
    expect(corsConfig.origin).toBe('https://staging.yourdomain.com');
  });

  it('should handle production-level load', async () => {
    // 부하 테스트
    const responses = await Promise.all(
      Array(100).fill().map(() => apiClient.get('/api/users'))
    );
    expect(responses.every(r => r.status === 200)).toBe(true);
  });
});
```

### **Production 환경에서:**
```javascript
// Production 환경 - 모니터링 및 헬스체크만
describe('Production Environment Health', () => {
  it('should respond to health checks', async () => {
    const response = await fetch('/health');
    expect(response.status).toBe(200);
  });

  it('should have all security headers', async () => {
    const response = await fetch('/');
    expect(response.headers.get('strict-transport-security')).toBeTruthy();
    expect(response.headers.get('x-frame-options')).toBe('DENY');
  });
});
```

## 🎯 Staging 환경이 필요한 이유

### **1. Production 문제 사전 방지:**
```javascript
// Development에서는 문제없었지만 Staging에서 발견되는 이슈들
const issues = [
  'Production 환경 설정 오류',
  '실제 외부 API 연동 문제',
  '보안 정책으로 인한 접근 제한',
  '성능 병목 지점',
  'HTTPS 환경에서만 발생하는 문제',
  '실제 데이터 크기로 인한 메모리 이슈'
];
```

### **2. 비즈니스 리스크 감소:**
- **고객 데이터 보호**: 실제 데이터로 테스트하지 않음
- **서비스 중단 방지**: Production 배포 전 마지막 검증
- **비용 절약**: Production 장애로 인한 손실 방지

### **3. 팀 협업 개선:**
- **QA팀**: Production과 동일한 환경에서 테스트
- **비즈니스팀**: 실제 사용 시나리오로 검증
- **DevOps팀**: 배포 프로세스 검증

**결론적으로, Staging은 "Production의 안전한 복제품"으로서 실제 배포 전 마지막 안전장치 역할을 합니다!** 🛡️

===

"""
동일한 코드를 기반으로, development 서버는 코드 변경을 실시간으로 동기화하면서 구동되고, production, staging 서버는 컴파일된 코드를 각각 다른 port로 서비스하려면, 어떤 방법이 좋을까요? git branch를 쓰는 것보다는 port만 다르게 하는게 낫겠죠?
"""

정말 훌륭한 접근 방식이네요! 동일한 코드베이스에서 환경별로 다른 방식으로 서비스하는 것이 **훨씬 효율적**입니다. Git branch를 나누는 것보다 **포트 기반 분리**가 관리하기 쉽고 일관성도 유지할 수 있어요.

## 🎯 최적화된 멀티 환경 구성 전략

### 1. **전체 포트 분배 계획**

```
📋 포트 할당 체계:
┌─────────────────┬──────────┬──────────┬──────────┐
│     서비스      │   Dev    │ Staging  │   Prod   │
├─────────────────┼──────────┼──────────┼──────────┤
│ API Gateway     │   201000   │   3010   │   3020   │
│ Auth Service    │   201011   │   3011   │   3021   │
│ Database Svc    │   3002   │   3012   │   3022   │
│ Management BE   │   3004   │   3014   │   3024   │
│ Management FE   │   3005   │   3015   │   3025   │
│ Project-1 BE    │   4001   │   4011   │   4021   │
│ Project-1 FE    │   4005   │   4015   │   4025   │
└─────────────────┴──────────┴──────────┴──────────┘

🔢 패턴: Base_Port + (Environment_Offset * 10)
- Development: +0  (201000, 201011, 3002...)
- Staging:     +10 (3010, 3011, 3012...)
- Production:  +20 (3020, 3021, 3022...)
```

### 2. **통합 Docker Compose 구성**

#### **docker-compose.yml (기본 - 모든 환경 동시 실행)**
```yaml
version: '3.8'

services:
  # ================================
  # 공유 인프라 (모든 환경 공통)
  # ================================
  shared-postgres:
    image: postgres:15
    container_name: shared-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./infrastructure/shared-database/postgresql/init:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - infrastructure

  shared-redis:
    image: redis:7-alpine
    container_name: shared-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - infrastructure

  # ================================
  # DEVELOPMENT 환경 (코드 동기화)
  # ================================
  auth-service-dev:
    build:
      context: ./infrastructure/auth-service
      dockerfile: ../docker/dockerfiles/backend.dev.Dockerfile
    container_name: auth-service-dev
    environment:
      NODE_ENV: development
      ENVIRONMENT: development
      PORT: 201000
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/auth_dev_db
      REDIS_URL: redis://shared-redis:6379
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET_DEV}
    volumes:
      # 🔥 실시간 코드 동기화
      - ./infrastructure/auth-service:/app
      - /app/node_modules
      - auth_dev_node_modules:/app/node_modules
    ports:
      - "201011:201000"
    command: npm run dev
    networks:
      - infrastructure
    depends_on:
      - shared-postgres
      - shared-redis
    restart: unless-stopped

  management-frontend-dev:
    build:
      context: ./management-hub/frontend
      dockerfile: ../../docker/dockerfiles/frontend.dev.Dockerfile
    container_name: management-frontend-dev
    environment:
      NODE_ENV: development
      ENVIRONMENT: development
      NEXT_PUBLIC_API_REST_URL: http://localhost:3004
      NEXT_PUBLIC_GATEWAY_URL: http://localhost:201000
      CHOKIDAR_USEPOLLING: 1
      WATCHPACK_POLLING: 1
    volumes:
      # 🔥 실시간 코드 동기화 + Hot Reload
      - ./management-hub/frontend:/app
      - /app/node_modules
      - /app/.next
      - mgmt_fe_dev_node_modules:/app/node_modules
    ports:
      - "3005:201000"
    command: npm run dev
    networks:
      - infrastructure
    restart: unless-stopped

  # ================================
  # STAGING 환경 (컴파일된 코드)
  # ================================
  auth-service-staging:
    build:
      context: ./infrastructure/auth-service
      dockerfile: ../docker/dockerfiles/backend.prod.Dockerfile
      args:
        NODE_ENV: production
    container_name: auth-service-staging
    environment:
      NODE_ENV: production
      ENVIRONMENT: staging
      PORT: 201000
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/auth_staging_db
      REDIS_URL: redis://shared-redis:6379
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET_STAGING}
    ports:
      - "3011:201000"
    command: npm start
    networks:
      - infrastructure
    depends_on:
      - shared-postgres
      - shared-redis
    restart: always
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

  management-frontend-staging:
    build:
      context: ./management-hub/frontend
      dockerfile: ../../docker/dockerfiles/frontend.prod.Dockerfile
      args:
        NODE_ENV: production
        NEXT_PUBLIC_API_REST_URL: http://localhost:3014
        NEXT_PUBLIC_GATEWAY_URL: http://localhost:3010
    container_name: management-frontend-staging
    environment:
      NODE_ENV: production
      ENVIRONMENT: staging
      PORT: 201000
    ports:
      - "3015:201000"
    command: npm start
    networks:
      - infrastructure
    restart: always

  # ================================
  # PRODUCTION 환경 (컴파일된 코드)
  # ================================
  auth-service-prod:
    build:
      context: ./infrastructure/auth-service
      dockerfile: ../docker/dockerfiles/backend.prod.Dockerfile
      args:
        NODE_ENV: production
    container_name: auth-service-prod
    environment:
      NODE_ENV: production
      ENVIRONMENT: production
      PORT: 201000
      DATABASE_URL: postgresql://postgres:${POSTGRES_PASSWORD}@shared-postgres:5432/auth_prod_db
      REDIS_URL: redis://shared-redis:6379
      JWT_ACCESS_SECRET: ${JWT_ACCESS_SECRET_PROD}
    ports:
      - "3021:201000"
    command: npm start
    networks:
      - infrastructure
    depends_on:
      - shared-postgres
      - shared-redis
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G

  management-frontend-prod:
    build:
      context: ./management-hub/frontend
      dockerfile: ../../docker/dockerfiles/frontend.prod.Dockerfile
      args:
        NODE_ENV: production
        NEXT_PUBLIC_API_REST_URL: http://localhost:3024
        NEXT_PUBLIC_GATEWAY_URL: http://localhost:3020
    container_name: management-frontend-prod
    environment:
      NODE_ENV: production
      ENVIRONMENT: production
      PORT: 201000
    ports:
      - "3025:201000"
    command: npm start
    networks:
      - infrastructure
    restart: always

volumes:
  postgres_data:
  redis_data:
  # 개발 환경 전용 node_modules 볼륨들
  auth_dev_node_modules:
  mgmt_fe_dev_node_modules:

networks:
  infrastructure:
    driver: bridge
```

### 3. **환경별 스마트 관리 스크립트**

#### **scripts/multi-env-manager.sh**
```bash
#!/bin/bash

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

print_header() {
    echo -e "${PURPLE}"
    echo "╔══════════════════════════════════════════════════════════════════════════════╗"
    echo "║                        🐳 멀티 환경 Docker 관리자                             ║"
    echo "╚══════════════════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# 서비스 그룹 정의
declare -A SERVICE_GROUPS=(
    ["infrastructure"]="shared-postgres shared-redis"
    ["dev"]="auth-service-dev database-service-dev api-gateway-dev management-backend-dev management-frontend-dev"
    ["staging"]="auth-service-staging database-service-staging api-gateway-staging management-backend-staging management-frontend-staging"
    ["prod"]="auth-service-prod database-service-prod api-gateway-prod management-backend-prod management-frontend-prod"
    ["all-dev"]="infrastructure dev"
    ["all-staging"]="infrastructure staging"
    ["all-prod"]="infrastructure prod"
    ["everything"]="infrastructure dev staging prod"
)

# 포트 정보
declare -A PORT_INFO=(
    ["dev"]="Development: 201011-3005, 4001-4005 (Hot Reload 활성화)"
    ["staging"]="Staging: 3011-3015, 4011-4015 (컴파일된 코드)"
    ["prod"]="Production: 3021-3025, 4021-4025 (최적화된 코드)"
)

# 사용법
usage() {
    print_header
    echo "사용법: $0 [ACTION] [TARGET] [OPTIONS]"
    echo ""
    echo "🎯 ACTIONS:"
    echo "  start                     서비스 시작"
    echo "  stop                      서비스 중지"
    echo "  restart                   서비스 재시작"
    echo "  rebuild                   이미지 리빌드 후 시작"
    echo "  logs                      로그 확인"
    echo "  status                    서비스 상태 확인"
    echo "  clean                     중지 후 이미지/볼륨 정리"
    echo ""
    echo "🎨 TARGETS:"
    echo "  infrastructure            공유 인프라 (DB, Redis)"
    echo "  dev                       개발 환경 (Hot Reload)"
    echo "  staging                   스테이징 환경 (컴파일)"
    echo "  prod                      프로덕션 환경 (최적화)"
    echo "  all-dev                   인프라 + 개발 환경"
    echo "  all-staging              인프라 + 스테이징 환경"
    echo "  all-prod                 인프라 + 프로덕션 환경"
    echo "  everything               모든 환경"
    echo ""
    echo "🌐 PORT 정보:"
    for env in dev staging prod; do
        echo "  ${PORT_INFO[$env]}"
    done
    echo ""
    echo "💡 사용 예시:"
    echo "  $0 start infrastructure   # 인프라만 시작"
    echo "  $0 start all-dev          # 개발 환경 전체 시작"
    echo "  $0 rebuild staging        # 스테이징 환경 리빌드"
    echo "  $0 logs dev auth-service-dev  # 개발 환경 인증 서비스 로그"
    echo "  $0 status everything      # 모든 서비스 상태 확인"
}

# 서비스 목록 가져오기
get_services() {
    local target=$1
    local services=""
    
    if [[ ${SERVICE_GROUPS[$target]+_} ]]; then
        # 그룹인 경우
        local group_services="${SERVICE_GROUPS[$target]}"
        for group in $group_services; do
            if [[ ${SERVICE_GROUPS[$group]+_} ]]; then
                # 중첩 그룹
                services="$services ${SERVICE_GROUPS[$group]}"
            else
                services="$services $group"
            fi
        done
    else
        # 단일 서비스
        services=$target
    fi
    
    echo $services
}

# Docker Compose 명령 실행
run_compose() {
    local action=$1
    local services=$2
    shift 2
    
    docker-compose $action $services "$@"
}

# 환경별 빌드 최적화
optimize_build() {
    local target=$1
    
    case $target in
        *dev*)
            print_info "개발 환경 빌드: 캐시 활용, 개발 도구 포함"
            ;;
        *staging*)
            print_info "스테이징 환경 빌드: 프로덕션 모드, 최적화 활성화"
            export NODE_ENV=production
            ;;
        *prod*)
            print_info "프로덕션 환경 빌드: 최대 최적화, 보안 강화"
            export NODE_ENV=production
            export BUILD_OPTIMIZATION=true
            ;;
    esac
}

# 메인 로직
main() {
    if [ $# -lt 2 ]; then
        usage
        exit 1
    fi
    
    local action=$1
    local target=$2
    shift 2
    
    # 프로젝트 루트로 이동
    cd "$(dirname "$0")/.."
    
    # 환경 파일 로드
    if [ -f ".env" ]; then
        source .env
    fi
    
    # 서비스 목록 가져오기
    local services=$(get_services "$target")
    
    print_header
    print_info "Target: $target"
    print_info "Services: $services"
    print_info "Action: $action"
    echo ""
    
    case $action in
        "start")
            print_info "🚀 서비스를 시작합니다..."
            
            # 인프라 먼저 시작 (다른 환경이 포함된 경우)
            if [[ $target == *"all-"* ]] || [[ $target == "everything" ]]; then
                print_info "📡 인프라 서비스를 먼저 시작합니다..."
                run_compose up -d ${SERVICE_GROUPS["infrastructure"]}
                sleep 5
            fi
            
            run_compose up -d $services
            print_success "서비스가 시작되었습니다!"
            
            # 접속 정보 표시
            show_service_info "$target"
            ;;
            
        "stop")
            print_info "🛑 서비스를 중지합니다..."
            run_compose down $services
            print_success "서비스가 중지되었습니다!"
            ;;
            
        "restart")
            print_info "🔄 서비스를 재시작합니다..."
            run_compose restart $services
            print_success "서비스가 재시작되었습니다!"
            ;;
            
        "rebuild")
            print_info "🔨 이미지를 리빌드합니다..."
            optimize_build "$target"
            
            # 캐시 사용 여부 결정
            local build_args="--build"
            if [[ $target == *"prod"* ]] || [[ $target == *"staging"* ]]; then
                build_args="--build --no-cache"
                print_warning "프로덕션/스테이징 환경: 캐시 없이 빌드"
            fi
            
            run_compose up -d $build_args $services
            print_success "리빌드가 완료되었습니다!"
            
            show_service_info "$target"
            ;;
            
        "logs")
            local service_name=${1:-""}
            if [ -n "$service_name" ]; then
                print_info "📋 $service_name 로그를 확인합니다..."
                run_compose logs -f --tail=100 $service_name
            else
                print_info "📋 모든 서비스 로그를 확인합니다..."
                run_compose logs -f --tail=50 $services
            fi
            ;;
            
        "status")
            print_info "📊 서비스 상태를 확인합니다..."
            echo ""
            docker-compose ps $services
            echo ""
            
            # 상세 상태 정보
            for service in $services; do
                local status=$(docker-compose ps -q $service | xargs -r docker inspect --format='{{.State.Status}}' 2>/dev/null || echo "not found")
                case $status in
                    "running")
                        print_success "$service: 실행 중"
                        ;;
                    "exited")
                        print_error "$service: 중지됨"
                        ;;
                    "not found")
                        print_warning "$service: 컨테이너 없음"
                        ;;
                    *)
                        print_warning "$service: $status"
                        ;;
                esac
            done
            ;;
            
        "clean")
            print_warning "⚠️  서비스 중지 및 정리를 시작합니다..."
            read -p "계속하시겠습니까? (y/N): " -n 1 -r
            echo ""
            
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                run_compose down $services
                docker-compose down --volumes --remove-orphans
                docker system prune -f
                print_success "정리가 완료되었습니다!"
            else
                print_info "작업이 취소되었습니다."
            fi
            ;;
            
        *)
            print_error "지원하지 않는 액션: $action"
            usage
            exit 1
            ;;
    esac
}

# 서비스 접속 정보 표시
show_service_info() {
    local target=$1
    
    echo ""
    print_success "🌐 서비스 접속 정보:"
    
    case $target in
        *"dev"*)
            echo "  🔥 Development (Hot Reload):"
            echo "     • Management Hub: http://localhost:3005"
            echo "     • API Gateway: http://localhost:201000"
            echo "     • Auth Service: http://localhost:201011"
            ;;
        *"staging"*)
            echo "  🧪 Staging (Compiled):"
            echo "     • Management Hub: http://localhost:3015"
            echo "     • API Gateway: http://localhost:3010"
            echo "     • Auth Service: http://localhost:3011"
            ;;
        *"prod"*)
            echo "  🚀 Production (Optimized):"
            echo "     • Management Hub: http://localhost:3025"
            echo "     • API Gateway: http://localhost:3020"
            echo "     • Auth Service: http://localhost:3021"
            ;;
        "everything")
            echo "  🔥 Development: http://localhost:3005 (Hot Reload)"
            echo "  🧪 Staging: http://localhost:3015 (Compiled)"
            echo "  🚀 Production: http://localhost:3025 (Optimized)"
            ;;
    esac
    
    echo ""
    print_info "💡 로그 확인: $0 logs $target [service-name]"
    print_info "📊 상태 확인: $0 status $target"
}

# 스크립트 실행
main "$@"
```

### 4. **환경별 최적화된 Dockerfile**

#### **개발용 Dockerfile (dockerfiles/backend.dev.Dockerfile)**
```dockerfile
FROM node:18-alpine

# 개발 도구 설치
RUN apk add --no-cache git python3 make g++

WORKDIR /app

# 패키지 설치 (개발 의존성 포함)
COPY package*.json ./
RUN npm ci --include=dev

# 글로벌 개발 도구
RUN npm install -g nodemon concurrently

# 개발용 사용자 생성
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001 -G nodejs

# 소스 코드 복사 (볼륨 마운트로 대체됨)
COPY . .
RUN chown -R nodejs:nodejs /app

USER nodejs

EXPOSE 201000

# 🔥 핫 리로드 명령
CMD ["npm", "run", "dev"]
```

#### **프로덕션용 Dockerfile (dockerfiles/backend.prod.Dockerfile)**
```dockerfile
# 멀티 스테이지 빌드
FROM node:18-alpine AS dependencies
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .

# 🚀 프로덕션 빌드 (환경에 따른 최적화)
ARG NODE_ENV=production
ENV NODE_ENV=${NODE_ENV}

# TypeScript 컴파일 (있는 경우)
RUN npm run build 2>/dev/null || echo "No build script found"

# 런타임 스테이지
FROM node:18-alpine AS runtime

# 보안을 위한 non-root 사용자
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001 -G nodejs

WORKDIR /app

# 필요한 파일만 복사
COPY --from=dependencies --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app .

USER nodejs

EXPOSE 201000

# 🚀 프로덕션 실행
CMD ["npm", "start"]
```

### 5. **환경별 package.json 스크립트**

```json
{
  "scripts": {
    "dev": "nodemon --watch src --ext js,ts,json,graphql --exec node src/app.js",
    "dev:debug": "nodemon --inspect=0.0.0.0:9229 --watch src --exec node src/app.js",
    "start": "node src/app.js",
    "build": "npm run build:clean && npm run build:compile",
    "build:clean": "rm -rf dist",
    "build:compile": "tsc || babel src --out-dir dist --extensions '.ts,.js'",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src --ext .js,.ts",
    "lint:fix": "eslint src --ext .js,.ts --fix"
  },
  "nodemonConfig": {
    "watch": ["src"],
    "ext": "js,ts,json,graphql",
    "ignore": ["node_modules", "*.test.js", "dist"],
    "delay": 1000,
    "env": {
      "NODE_ENV": "development"
    }
  }
}
```

### 6. **환경별 설정 관리**

#### **config/index.js (동적 환경 설정)**
```javascript
const path = require('path');

// 환경별 설정 로드
const loadConfig = () => {
  const environment = process.env.ENVIRONMENT || 'development';
  const nodeEnv = process.env.NODE_ENV || 'development';
  
  console.log(`🎯 Environment: ${environment}, Node ENV: ${nodeEnv}`);
  
  const baseConfig = {
    environment,
    nodeEnv,
    port: process.env.PORT || 201000,
    
    // 데이터베이스 설정
    database: {
      url: process.env.DATABASE_URL,
      pool: {
        min: nodeEnv === 'production' ? 5 : 2,
        max: nodeEnv === 'production' ? 20 : 10
      }
    },
    
    // Redis 설정
    redis: {
      url: process.env.REDIS_URL || 'redis://localhost:6379',
      keyPrefix: `app:${environment}:`
    },
    
    // JWT 설정
    jwt: {
      accessSecret: process.env.JWT_ACCESS_SECRET,
      refreshSecret: process.env.JWT_REFRESH_SECRET,
      accessExpiresIn: nodeEnv === 'production' ? '15m' : '1h',
      refreshExpiresIn: '7d'
    }
  };
  
  // 환경별 특별 설정
  const envConfigs = {
    development: {
      logging: {
        level: 'debug',
        prettyPrint: true
      },
      cors: {
        origin: '*',
        credentials: true
      },
      rateLimiting: {
        enabled: false
      },
      hotReload: true,
      debugMode: true
    },
    
    staging: {
      logging: {
        level: 'info',
        prettyPrint: false
      },
      cors: {
        origin: ['http://localhost:3015', 'https://staging.yourdomain.com'],
        credentials: true
      },
      rateLimiting: {
        enabled: true,
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 1000 // requests per window
      },
      monitoring: {
        enabled: true,
        metricsPath: '/metrics'
      }
    },
    
    production: {
      logging: {
        level: 'warn',
        prettyPrint: false,
        file: '/var/log/app.log'
      },
      cors: {
        origin: ['https://yourdomain.com'],
        credentials: true
      },
      rateLimiting: {
        enabled: true,
        windowMs: 15 * 60 * 1000,
        max: 500
      },
      security: {
        helmet: true,
        https: true,
        hsts: true
      },
      monitoring: {
        enabled: true,
        metricsPath: '/metrics',
        alerting: true
      },
      performance: {
        compression: true,
        caching: true
      }
    }
  };
  
  return {
    ...baseConfig,
    ...envConfigs[environment]
  };
};

module.exports = loadConfig();
```

### 7. **실제 사용 예시**

#### **일상적인 개발 워크플로우:**
```bash
# 1. 개발 환경만 시작 (Hot Reload)
./scripts/multi-env-manager.sh start all-dev
# → http://localhost:3005 (개발)

# 2. 코드 변경하면서 개발...
# (파일 저장시 자동으로 재시작됨)

# 3. 스테이징에서 테스트
./scripts/multi-env-manager.sh rebuild staging
# → http://localhost:3015 (스테이징)

# 4. 프로덕션 배포 전 최종 확인
./scripts/multi-env-manager.sh rebuild prod
# → http://localhost:3025 (프로덕션)

# 5. 모든 환경 동시 실행 (데모/비교용)
./scripts/multi-env-manager.sh start everything
# → 3개 환경 모두 동시 실행

# 6. 로그 확인
./scripts/multi-env-manager.sh logs dev auth-service-dev
./scripts/multi-env-manager.sh logs staging

# 7. 상태 확인
./scripts/multi-env-manager.sh status everything
```

## 🎯 이 방식의 장점

### **1. 일관성 보장:**
- ✅ 동일한 코드베이스 사용
- ✅ 환경별 차이점은 설정만으로 관리
- ✅ Git branch 복잡성 제거

### **2. 개발 효율성:**
- ✅ Development: 즉시 변경사항 반영
- ✅ Staging/Production: 컴파일된 안정적 코드
- ✅ 포트만 다르므로 동시 실행 가능

### **3. 운영 편의성:**
- ✅ 한 번의 명령으로 환경별 관리
- ✅ 환경 간 쉬운 비교 및 테스트
- ✅ 프로덕션 배포 전 최종 검증 가능

### **4. 리소스 효율성:**
- ✅ 개발용: 실시간 동기화로 빠른 피드백
- ✅ 운영용: 최적화된 컴파일 코드로 성능 향상
- ✅ 공유 인프라로 리소스 절약

이 방식이 Git branch 분리보다 훨씬 관리하기 쉽고 실용적입니다! 🚀