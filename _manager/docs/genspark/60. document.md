"""
프로젝트에서 개발/구현/기능 관련 문서들은 어떤 폴더에서 저장.관리하나요?
"""

좋은 질문이네요! 개발/구현/기능 관련 문서들은 **계층적이고 접근성 좋은 구조**로 관리하는 것이 중요합니다. 다음과 같이 구성하는 것을 추천합니다:

## 📚 문서 관리 구조

### 1. **전체 프로젝트 레벨 문서** (`/docs/`)
```
docs/
├── architecture/                    # 전체 아키텍처 문서
│   ├── system-overview.md
│   ├── database-design.md
│   ├── api-gateway.md
│   └── security-architecture.md
├── development/                     # 개발 가이드라인
│   ├── coding-standards.md
│   ├── git-workflow.md
│   ├── code-review-guide.md
│   └── development-setup.md
├── deployment/                      # 배포 관련
│   ├── docker-guide.md
│   ├── ci-cd-pipeline.md
│   └── infrastructure.md
└── troubleshooting/                 # 문제 해결
    ├── common-issues.md
    └── debugging-guide.md
```

### 2. **개별 프로젝트 레벨 문서** (`/projects/project-1/docs/`)
```
projects/project-1/
├── docs/                           # 프로젝트별 개발 문서
│   ├── features/                   # 기능 명세서
│   │   ├── user-management.md
│   │   ├── authentication.md
│   │   ├── payment-system.md
│   │   └── notification.md
│   ├── technical/                  # 기술 명세서
│   │   ├── database-schema.md
│   │   ├── api-specifications.md
│   │   ├── component-specs.md
│   │   └── integration-guide.md
│   ├── implementation/             # 구현 가이드
│   │   ├── backend-implementation.md
│   │   ├── frontend-implementation.md
│   │   ├── testing-strategy.md
│   │   └── performance-guide.md
│   ├── changelogs/                 # 변경 이력
│   │   ├── CHANGELOG.md
│   │   ├── migration-guide.md
│   │   └── breaking-changes.md
│   └── README.md                   # 프로젝트 개요
├── backend/
│   ├── docs/                       # 백엔드 특화 문서
│   │   ├── api/                    # API 문서
│   │   │   ├── graphql-schema.md
│   │   │   ├── resolvers.md
│   │   │   └── mutations.md
│   │   ├── services/               # 서비스 문서
│   │   └── database/               # 데이터베이스 문서
│   │       ├── erd.md
│   │       └── queries.md
│   └── README.md
└── frontend/
    ├── docs/                       # 프론트엔드 특화 문서
    │   ├── components/             # 컴포넌트 문서
    │   │   ├── component-library.md
    │   │   └── style-guide.md
    │   ├── pages/                  # 페이지별 문서
    │   ├── hooks/                  # 커스텀 훅 문서
    │   └── state-management.md     # 상태 관리 문서
    └── README.md
```

## 🎯 문서 유형별 위치 가이드

### **기능 명세서** (`/docs/features/`)
- 사용자 스토리
- 기능 요구사항
- 비즈니스 로직
- 사용자 플로우

### **기술 명세서** (`/docs/technical/`)
- API 스펙
- 데이터베이스 스키마
- 시스템 아키텍처
- 기술 스택 선택 이유

### **구현 가이드** (`/docs/implementation/`)
- 개발 방법론
- 코딩 컨벤션
- 테스트 전략
- 성능 최적화 가이드

### **API 문서** (`/backend/docs/api/`)
- GraphQL 스키마
- Resolver 문서
- Mutation 가이드
- 인증/인가 가이드

## 🛠️ 추천 문서 도구 및 자동화

### 1. **문서 자동 생성**
```javascript
// package.json scripts 예시
{
  "scripts": {
    "docs:api": "graphql-doc-generator",
    "docs:components": "storybook build-docs",
    "docs:serve": "docsify serve docs"
  }
}
```

### 2. **문서 도구 추천**
- **API 문서**: GraphQL Playground, Apollo Studio
- **컴포넌트 문서**: Storybook
- **정적 사이트**: Docsify, GitBook, VuePress
- **다이어그램**: Mermaid, PlantUML

### 3. **문서 템플릿**
```markdown
# 기능 명세서 템플릿 (/docs/features/feature-template.md)

## 개요
- 기능 이름:
- 담당자:
- 작성일:

## 요구사항
### 기능적 요구사항
### 비기능적 요구사항

## 기술 스택
### Backend
### Frontend
### Database

## API 명세
### GraphQL Queries
### GraphQL Mutations

## 테스트 계획
### 단위 테스트
### 통합 테스트
### E2E 테스트

## 배포 계획
```

## 📋 문서 관리 베스트 프랙티스

### 1. **문서 생명주기 관리**
- 작성 → 리뷰 → 승인 → 배포 → 업데이트
- Git으로 문서 버전 관리
- Pull Request를 통한 문서 리뷰

### 2. **자동화된 문서 생성**
- 코드에서 자동으로 API 문서 생성
- JSDoc, TypeScript 주석 활용
- CI/CD에서 문서 빌드/배포 자동화

### 3. **문서 접근성**
- 중앙집중식 문서 포털 구축
- 검색 기능 제공
- 태그 및 카테고리 분류

이렇게 구성하시면 개발팀이 필요한 문서를 쉽게 찾고 유지관리할 수 있을 것입니다! 특정 문서 유형에 대해 더 자세한 가이드가 필요하시면 말씀해 주세요.

===

"""
frontend에 프로젝트 문서를 관리하는 게시판 형식의 module/page를 추가하고, 문서 폴더/파일들을 접근하고, markdown 문서를 html/text로 확인할 수도 있고, 수정/편집할 수 있도록 하는 건 어떤가요?
"""

정말 훌륭한 아이디어네요! 개발팀이 브라우저에서 직접 문서를 관리할 수 있는 통합 시스템을 만드는 것이군요. 이를 구현하기 위한 구체적인 구조와 방법을 제안해드리겠습니다.

## 🎯 문서 관리 시스템 아키텍처

### 1. **디렉토리 구조 업데이트**

```
projects/project-1/
├── frontend/
│   ├── nextjs-app/
│   │   ├── pages/
│   │   │   ├── docs/                    # 문서 관리 페이지
│   │   │   │   ├── index.js             # 문서 목록/대시보드
│   │   │   │   ├── [...slug].js         # 동적 문서 경로
│   │   │   │   └── editor/
│   │   │   │       └── [...path].js     # 문서 편집기
│   │   │   └── api/
│   │   │       └── docs/                # 문서 API 엔드포인트
│   │   │           ├── list.js          # 문서 목록 조회
│   │   │           ├── read.js          # 문서 읽기
│   │   │           ├── write.js         # 문서 쓰기
│   │   │           ├── delete.js        # 문서 삭제
│   │   │           └── upload.js        # 파일 업로드
│   │   ├── components/
│   │   │   └── docs/                    # 문서 관련 컴포넌트
│   │   │       ├── DocumentViewer.jsx   # 마크다운 뷰어
│   │   │       ├── DocumentEditor.jsx   # 마크다운 에디터
│   │   │       ├── FileExplorer.jsx     # 파일 탐색기
│   │   │       ├── DocumentList.jsx     # 문서 목록
│   │   │       ├── SearchBar.jsx        # 문서 검색
│   │   │       └── DocumentUpload.jsx   # 파일 업로드
│   │   └── lib/
│   │       └── docs/                    # 문서 관련 유틸리티
│   │           ├── fileSystem.js        # 파일 시스템 조작
│   │           ├── markdownParser.js    # 마크다운 파싱
│   │           └── documentSearch.js    # 문서 검색 로직
├── backend/
│   └── src/
│       ├── graphql/
│       │   ├── resolvers/
│       │   │   └── document.js          # 문서 GraphQL resolver
│       │   └── schemas/
│       │       └── document.graphql     # 문서 GraphQL 스키마
│       └── services/
│           └── documentService.js       # 문서 비즈니스 로직
└── docs/                               # 실제 문서 저장소
    └── [기존 문서 구조]
```

## 🚀 구현 상세 계획

### 1. **백엔드 API 설계 (GraphQL)**

```graphql
# document.graphql
type Document {
  id: ID!
  path: String!
  name: String!
  content: String!
  type: DocumentType!
  size: Int!
  lastModified: DateTime!
  author: String
  tags: [String!]
}

type DocumentTree {
  name: String!
  path: String!
  type: FileType!
  children: [DocumentTree!]
}

enum DocumentType {
  MARKDOWN
  TEXT
  JSON
  YAML
}

enum FileType {
  FILE
  DIRECTORY
}

type Query {
  # 문서 목록 조회
  getDocuments(path: String): [Document!]!
  
  # 문서 트리 구조 조회
  getDocumentTree(path: String): DocumentTree!
  
  # 특정 문서 조회
  getDocument(path: String!): Document
  
  # 문서 검색
  searchDocuments(query: String!, path: String): [Document!]!
}

type Mutation {
  # 문서 생성/업데이트
  saveDocument(path: String!, content: String!, author: String): Document!
  
  # 문서 삭제
  deleteDocument(path: String!): Boolean!
  
  # 폴더 생성
  createFolder(path: String!): Boolean!
  
  # 파일/폴더 이동
  moveDocument(fromPath: String!, toPath: String!): Boolean!
}
```

### 2. **프론트엔드 컴포넌트 구현**

#### **DocumentViewer.jsx** - 마크다운 뷰어
```jsx
import React, { useState, useEffect } from 'react';
import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import remarkGfm from 'remark-gfm';

const DocumentViewer = ({ documentPath, onEdit }) => {
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(true);

  return (
    <div className="document-viewer">
      <div className="viewer-header">
        <h2>{documentPath}</h2>
        <button onClick={() => onEdit(documentPath)}>
          편집
        </button>
      </div>
      
      <div className="viewer-content">
        <ReactMarkdown
          remarkPlugins={[remarkGfm]}
          components={{
            code({node, inline, className, children, ...props}) {
              const match = /language-(\w+)/.exec(className || '')
              return !inline && match ? (
                <SyntaxHighlighter
                  style={vsDark}
                  language={match[1]}
                  PreTag="div"
                  {...props}
                >
                  {String(children).replace(/\n$/, '')}
                </SyntaxHighlighter>
              ) : (
                <code className={className} {...props}>
                  {children}
                </code>
              )
            }
          }}
        >
          {content}
        </ReactMarkdown>
      </div>
    </div>
  );
};
```

#### **DocumentEditor.jsx** - 마크다운 에디터
```jsx
import React, { useState, useEffect } from 'react';
import MDEditor from '@uiw/react-md-editor';

const DocumentEditor = ({ documentPath, initialContent, onSave, onCancel }) => {
  const [content, setContent] = useState(initialContent || '');
  const [isPreview, setIsPreview] = useState(false);

  const handleSave = async () => {
    try {
      await onSave(documentPath, content);
      // 성공 메시지
    } catch (error) {
      // 에러 처리
    }
  };

  return (
    <div className="document-editor">
      <div className="editor-toolbar">
        <button onClick={() => setIsPreview(!isPreview)}>
          {isPreview ? '편집' : '미리보기'}
        </button>
        <button onClick={handleSave}>저장</button>
        <button onClick={onCancel}>취소</button>
      </div>

      <MDEditor
        value={content}
        onChange={setContent}
        preview={isPreview ? 'preview' : 'edit'}
        height={600}
      />
    </div>
  );
};
```

#### **FileExplorer.jsx** - 파일 탐색기
```jsx
import React, { useState, useEffect } from 'react';
import { FiFolder, FiFile, FiPlus, FiEdit, FiTrash2 } from 'react-icons/fi';

const FileExplorer = ({ onFileSelect, onFileEdit, onFileDelete }) => {
  const [fileTree, setFileTree] = useState(null);
  const [expandedFolders, setExpandedFolders] = useState(new Set());

  const toggleFolder = (path) => {
    const newExpanded = new Set(expandedFolders);
    if (newExpanded.has(path)) {
      newExpanded.delete(path);
    } else {
      newExpanded.add(path);
    }
    setExpandedFolders(newExpanded);
  };

  const renderTreeNode = (node, level = 0) => (
    <div key={node.path} style={{ marginLeft: level * 20 }}>
      <div className="file-item">
        {node.type === 'DIRECTORY' ? (
          <>
            <FiFolder onClick={() => toggleFolder(node.path)} />
            <span onClick={() => toggleFolder(node.path)}>
              {node.name}
            </span>
          </>
        ) : (
          <>
            <FiFile />
            <span onClick={() => onFileSelect(node.path)}>
              {node.name}
            </span>
            <div className="file-actions">
              <FiEdit onClick={() => onFileEdit(node.path)} />
              <FiTrash2 onClick={() => onFileDelete(node.path)} />
            </div>
          </>
        )}
      </div>
      
      {node.type === 'DIRECTORY' && 
       expandedFolders.has(node.path) && 
       node.children?.map(child => 
         renderTreeNode(child, level + 1)
       )}
    </div>
  );

  return (
    <div className="file-explorer">
      <div className="explorer-header">
        <h3>문서 탐색기</h3>
        <FiPlus onClick={() => {/* 새 파일/폴더 생성 */}} />
      </div>
      
      <div className="explorer-content">
        {fileTree && renderTreeNode(fileTree)}
      </div>
    </div>
  );
};
```

### 3. **메인 문서 관리 페이지**

#### **pages/docs/index.js** - 문서 대시보드
```jsx
import React, { useState, useEffect } from 'react';
import Layout from '../../components/Layout';
import FileExplorer from '../../components/docs/FileExplorer';
import DocumentViewer from '../../components/docs/DocumentViewer';
import DocumentEditor from '../../components/docs/DocumentEditor';
import SearchBar from '../../components/docs/SearchBar';

const DocsPage = () => {
  const [currentView, setCurrentView] = useState('viewer'); // viewer, editor
  const [selectedDocument, setSelectedDocument] = useState(null);
  const [documentContent, setDocumentContent] = useState('');

  const handleFileSelect = async (path) => {
    // 문서 내용 로드
    setSelectedDocument(path);
    setCurrentView('viewer');
  };

  const handleFileEdit = async (path) => {
    // 편집 모드로 전환
    setSelectedDocument(path);
    setCurrentView('editor');
  };

  const handleSaveDocument = async (path, content) => {
    // 문서 저장 API 호출
    try {
      // GraphQL mutation 호출
      console.log('Document saved:', path);
      setCurrentView('viewer');
    } catch (error) {
      console.error('Save failed:', error);
    }
  };

  return (
    <Layout>
      <div className="docs-container">
        <div className="docs-sidebar">
          <SearchBar onSearch={(query) => {/* 검색 처리 */}} />
          <FileExplorer 
            onFileSelect={handleFileSelect}
            onFileEdit={handleFileEdit}
            onFileDelete={(path) => {/* 삭제 처리 */}}
          />
        </div>

        <div className="docs-main">
          {selectedDocument ? (
            currentView === 'viewer' ? (
              <DocumentViewer 
                documentPath={selectedDocument}
                onEdit={handleFileEdit}
              />
            ) : (
              <DocumentEditor
                documentPath={selectedDocument}
                initialContent={documentContent}
                onSave={handleSaveDocument}
                onCancel={() => setCurrentView('viewer')}
              />
            )
          ) : (
            <div className="docs-welcome">
              <h2>문서 관리 시스템</h2>
              <p>좌측에서 문서를 선택하세요.</p>
            </div>
          )}
        </div>
      </div>
    </Layout>
  );
};

export default DocsPage;
```

## 🔧 필요한 패키지 및 도구

### **Frontend Dependencies**
```json
{
  "dependencies": {
    "@uiw/react-md-editor": "^3.20.2",
    "react-markdown": "^8.0.7",
    "remark-gfm": "^3.0.1",
    "react-syntax-highlighter": "^15.5.0",
    "react-icons": "^4.8.0",
    "fuse.js": "^6.6.2",
    "@monaco-editor/react": "^4.4.6"
  }
}
```

### **Backend Dependencies**
```json
{
  "dependencies": {
    "fs-extra": "^11.1.1",
    "chokidar": "^3.5.3",
    "gray-matter": "^4.0.3",
    "markdown-it": "^13.0.1"
  }
}
```

## 🎨 추가 기능 제안

### 1. **고급 기능들**
- **실시간 협업**: Socket.io를 통한 실시간 공동 편집
- **버전 관리**: Git 통합으로 문서 이력 관리
- **댓글 시스템**: 문서에 댓글 달기 기능
- **템플릿 시스템**: 자주 사용하는 문서 템플릿 제공

### 2. **사용자 경험**
- **드래그 앤 드롭**: 파일 업로드 및 구조 변경
- **단축키 지원**: 빠른 편집을 위한 키보드 단축키
- **다크 모드**: 개발자 친화적 테마
- **반응형 디자인**: 모바일에서도 사용 가능

### 3. **보안 및 권한**
- **사용자 인증**: 문서 접근 권한 관리
- **편집 로그**: 누가 언제 무엇을 수정했는지 추적
- **백업 시스템**: 정기적인 문서 백업

이렇게 구현하시면 개발팀이 코딩하면서 바로 문서를 관리할 수 있는 통합 환경을 만들 수 있을 것입니다! 특정 부분의 구현에 대해 더 자세한 설명이 필요하시면 말씀해 주세요.

===

"""
docker 내에 있는 모든 프로젝트들을 통합 관리(문서, git 저장소 등 CRU할 수 있는 
"""

정말 멋진 아이디어네요! Docker 환경 내에서 모든 프로젝트들을 통합 관리할 수 있는 **Project Management Hub**를 만들어보겠습니다. 이는 여러 프로젝트의 문서, Git 저장소, 배포 상태 등을 한 곳에서 관리할 수 있는 중앙집중식 대시보드입니다.

## 🎯 통합 관리 시스템 아키텍처

### 1. **전체 시스템 구조**

```
workspace/
├── management-hub/                   # 통합 관리 시스템
│   ├── frontend/                    # 관리 대시보드 (Next.js)
│   │   ├── pages/
│   │   │   ├── index.js            # 메인 대시보드
│   │   │   ├── projects/           # 프로젝트 관리
│   │   │   │   ├── index.js        # 프로젝트 목록
│   │   │   │   ├── [id]/
│   │   │   │   │   ├── index.js    # 프로젝트 상세
│   │   │   │   │   ├── docs.js     # 문서 관리
│   │   │   │   │   ├── git.js      # Git 관리
│   │   │   │   │   ├── deploy.js   # 배포 관리
│   │   │   │   │   └── settings.js # 설정
│   │   │   │   └── create.js       # 새 프로젝트 생성
│   │   │   ├── docs/               # 전체 문서 관리
│   │   │   │   ├── index.js        # 문서 대시보드
│   │   │   │   ├── search.js       # 문서 검색
│   │   │   │   └── [...path].js    # 동적 문서 경로
│   │   │   ├── git/                # Git 통합 관리
│   │   │   │   ├── index.js        # Git 대시보드
│   │   │   │   ├── repositories.js # 저장소 목록
│   │   │   │   └── commits.js      # 커밋 히스토리
│   │   │   ├── deploy/             # 배포 관리
│   │   │   │   ├── index.js        # 배포 대시보드
│   │   │   │   ├── pipelines.js    # CI/CD 파이프라인
│   │   │   │   └── logs.js         # 배포 로그
│   │   │   └── api/                # API 엔드포인트
│   │   │       ├── projects/       # 프로젝트 API
│   │   │       ├── docs/           # 문서 API
│   │   │       ├── git/            # Git API
│   │   │       └── deploy/         # 배포 API
│   │   ├── components/
│   │   │   ├── layout/
│   │   │   │   ├── Sidebar.jsx     # 사이드바 네비게이션
│   │   │   │   ├── Header.jsx      # 헤더
│   │   │   │   └── Layout.jsx      # 레이아웃 컴포넌트
│   │   │   ├── projects/
│   │   │   │   ├── ProjectCard.jsx # 프로젝트 카드
│   │   │   │   ├── ProjectList.jsx # 프로젝트 목록
│   │   │   │   ├── ProjectForm.jsx # 프로젝트 생성/수정
│   │   │   │   └── ProjectStats.jsx # 프로젝트 통계
│   │   │   ├── docs/
│   │   │   │   ├── DocumentTree.jsx    # 문서 트리
│   │   │   │   ├── DocumentViewer.jsx  # 문서 뷰어
│   │   │   │   ├── DocumentEditor.jsx  # 문서 에디터
│   │   │   │   └── DocumentSearch.jsx  # 문서 검색
│   │   │   ├── git/
│   │   │   │   ├── GitRepository.jsx   # Git 저장소 컴포넌트
│   │   │   │   ├── CommitHistory.jsx   # 커밋 히스토리
│   │   │   │   ├── BranchManager.jsx   # 브랜치 관리
│   │   │   │   └── GitActions.jsx      # Git 액션 버튼들
│   │   │   └── deploy/
│   │   │       ├── DeploymentStatus.jsx # 배포 상태
│   │   │       ├── PipelineView.jsx     # 파이프라인 뷰
│   │   │       └── LogViewer.jsx        # 로그 뷰어
│   │   └── lib/
│   │       ├── api/                # API 클라이언트
│   │       ├── git/                # Git 유틸리티
│   │       ├── docker/             # Docker 유틸리티
│   │       └── filesystem/         # 파일시스템 유틸리티
│   ├── backend/                    # 백엔드 API 서버
│   │   ├── src/
│   │   │   ├── controllers/
│   │   │   │   ├── projectController.js    # 프로젝트 관리
│   │   │   │   ├── documentController.js   # 문서 관리
│   │   │   │   ├── gitController.js        # Git 관리
│   │   │   │   └── deployController.js     # 배포 관리
│   │   │   ├── services/
│   │   │   │   ├── projectService.js       # 프로젝트 서비스
│   │   │   │   ├── documentService.js      # 문서 서비스
│   │   │   │   ├── gitService.js           # Git 서비스
│   │   │   │   ├── dockerService.js        # Docker 서비스
│   │   │   │   └── deployService.js        # 배포 서비스
│   │   │   ├── models/
│   │   │   │   ├── Project.js              # 프로젝트 모델
│   │   │   │   ├── Document.js             # 문서 모델
│   │   │   │   └── Deployment.js           # 배포 모델
│   │   │   ├── routes/
│   │   │   │   ├── projects.js             # 프로젝트 라우트
│   │   │   │   ├── documents.js            # 문서 라우트
│   │   │   │   ├── git.js                  # Git 라우트
│   │   │   │   └── deploy.js               # 배포 라우트
│   │   │   ├── middleware/
│   │   │   │   ├── auth.js                 # 인증 미들웨어
│   │   │   │   └── validation.js           # 검증 미들웨어
│   │   │   └── utils/
│   │   │       ├── fileSystem.js           # 파일시스템 유틸
│   │   │       ├── gitUtils.js             # Git 유틸리티
│   │   │       └── dockerUtils.js          # Docker 유틸리티
│   │   └── package.json
│   ├── database/                   # 데이터베이스 설정
│   │   ├── migrations/
│   │   ├── seeds/
│   │   └── config/
│   └── docker-compose.yml         # 관리 시스템 Docker 설정
├── projects/                      # 개별 프로젝트들
│   ├── project-1/
│   ├── project-2/
│   └── project-n/
└── shared/                       # 공통 리소스
    ├── configs/
    ├── scripts/
    └── templates/
```

## 🚀 핵심 기능 구현

### 1. **프로젝트 통합 관리 대시보드**

#### **메인 대시보드 (pages/index.js)**
```jsx
import React, { useState, useEffect } from 'react';
import Layout from '../components/layout/Layout';
import ProjectCard from '../components/projects/ProjectCard';
import ProjectStats from '../components/projects/ProjectStats';

const Dashboard = () => {
  const [projects, setProjects] = useState([]);
  const [stats, setStats] = useState({});
  const [recentActivity, setRecentActivity] = useState([]);

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    try {
      const [projectsRes, statsRes, activityRes] = await Promise.all([
        fetch('/api/projects'),
        fetch('/api/stats'),
        fetch('/api/activity/recent')
      ]);
      
      setProjects(await projectsRes.json());
      setStats(await statsRes.json());
      setRecentActivity(await activityRes.json());
    } catch (error) {
      console.error('Dashboard data fetch failed:', error);
    }
  };

  return (
    <Layout>
      <div className="dashboard">
        <div className="dashboard-header">
          <h1>프로젝트 관리 허브</h1>
          <button className="btn-primary">
            새 프로젝트 생성
          </button>
        </div>

        {/* 전체 통계 */}
        <div className="stats-grid">
          <ProjectStats stats={stats} />
        </div>

        {/* 프로젝트 목록 */}
        <div className="projects-section">
          <h2>프로젝트 목록</h2>
          <div className="projects-grid">
            {projects.map(project => (
              <ProjectCard 
                key={project.id} 
                project={project}
                onUpdate={fetchDashboardData}
              />
            ))}
          </div>
        </div>

        {/* 최근 활동 */}
        <div className="activity-section">
          <h2>최근 활동</h2>
          <div className="activity-timeline">
            {recentActivity.map(activity => (
              <div key={activity.id} className="activity-item">
                <div className="activity-icon">
                  {activity.type === 'commit' && '📝'}
                  {activity.type === 'deploy' && '🚀'}
                  {activity.type === 'document' && '📄'}
                </div>
                <div className="activity-content">
                  <p>{activity.message}</p>
                  <span className="activity-time">
                    {activity.timestamp}
                  </span>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </Layout>
  );
};

export default Dashboard;
```

### 2. **Git 통합 관리 시스템**

#### **Git 서비스 (services/gitService.js)**
```javascript
const { execSync, spawn } = require('child_process');
const fs = require('fs-extra');
const path = require('path');

class GitService {
  constructor(projectPath) {
    this.projectPath = projectPath;
  }

  // Git 상태 확인
  async getStatus() {
    try {
      const status = execSync('git status --porcelain', {
        cwd: this.projectPath,
        encoding: 'utf8'
      });
      
      return {
        hasChanges: status.length > 0,
        changes: this.parseStatus(status)
      };
    } catch (error) {
      throw new Error(`Git status failed: ${error.message}`);
    }
  }

  // 브랜치 목록 조회
  async getBranches() {
    try {
      const branches = execSync('git branch -a', {
        cwd: this.projectPath,
        encoding: 'utf8'
      });
      
      return this.parseBranches(branches);
    } catch (error) {
      throw new Error(`Get branches failed: ${error.message}`);
    }
  }

  // 커밋 히스토리 조회
  async getCommitHistory(limit = 20) {
    try {
      const commits = execSync(
        `git log --oneline --graph -${limit} --pretty=format:"%h|%an|%ad|%s" --date=short`,
        { cwd: this.projectPath, encoding: 'utf8' }
      );
      
      return this.parseCommits(commits);
    } catch (error) {
      throw new Error(`Get commit history failed: ${error.message}`);
    }
  }

  // 파일 추가
  async addFiles(files) {
    try {
      const fileList = Array.isArray(files) ? files.join(' ') : files;
      execSync(`git add ${fileList}`, {
        cwd: this.projectPath
      });
      return true;
    } catch (error) {
      throw new Error(`Git add failed: ${error.message}`);
    }
  }

  // 커밋
  async commit(message, author) {
    try {
      execSync(`git commit -m "${message}" --author="${author}"`, {
        cwd: this.projectPath
      });
      return true;
    } catch (error) {
      throw new Error(`Git commit failed: ${error.message}`);
    }
  }

  // 푸시
  async push(branch = 'main') {
    try {
      execSync(`git push origin ${branch}`, {
        cwd: this.projectPath
      });
      return true;
    } catch (error) {
      throw new Error(`Git push failed: ${error.message}`);
    }
  }

  // 풀
  async pull(branch = 'main') {
    try {
      execSync(`git pull origin ${branch}`, {
        cwd: this.projectPath
      });
      return true;
    } catch (error) {
      throw new Error(`Git pull failed: ${error.message}`);
    }
  }

  // 브랜치 생성 및 체크아웃
  async createBranch(branchName) {
    try {
      execSync(`git checkout -b ${branchName}`, {
        cwd: this.projectPath
      });
      return true;
    } catch (error) {
      throw new Error(`Create branch failed: ${error.message}`);
    }
  }

  // 브랜치 전환
  async checkoutBranch(branchName) {
    try {
      execSync(`git checkout ${branchName}`, {
        cwd: this.projectPath
      });
      return true;
    } catch (error) {
      throw new Error(`Checkout branch failed: ${error.message}`);
    }
  }

  // Git 초기화
  async initRepository(remoteUrl) {
    try {
      if (!fs.existsSync(path.join(this.projectPath, '.git'))) {
        execSync('git init', { cwd: this.projectPath });
      }
      
      if (remoteUrl) {
        execSync(`git remote add origin ${remoteUrl}`, {
          cwd: this.projectPath
        });
      }
      
      return true;
    } catch (error) {
      throw new Error(`Git init failed: ${error.message}`);
    }
  }

  // 헬퍼 메서드들
  parseStatus(status) {
    return status.split('\n').filter(line => line.trim()).map(line => {
      const statusCode = line.substring(0, 2);
      const fileName = line.substring(3);
      return {
        file: fileName,
        status: this.getStatusDescription(statusCode)
      };
    });
  }

  parseBranches(branches) {
    return branches.split('\n')
      .filter(line => line.trim())
      .map(line => {
        const isRemote = line.includes('remotes/');
        const isCurrent = line.startsWith('*');
        const branchName = line.replace(/^\*?\s+/, '').replace('remotes/origin/', '');
        
        return {
          name: branchName,
          isRemote,
          isCurrent
        };
      });
  }

  parseCommits(commits) {
    return commits.split('\n')
      .filter(line => line.trim())
      .map(line => {
        const [hash, author, date, message] = line.split('|');
        return { hash, author, date, message };
      });
  }

  getStatusDescription(statusCode) {
    const statusMap = {
      'M ': 'Modified',
      'A ': 'Added',
      'D ': 'Deleted',
      'R ': 'Renamed',
      'C ': 'Copied',
      'U ': 'Updated',
      '??': 'Untracked'
    };
    return statusMap[statusCode] || 'Unknown';
  }
}

module.exports = GitService;
```

### 3. **Git 관리 컴포넌트**

#### **GitRepository.jsx**
```jsx
import React, { useState, useEffect } from 'react';
import { FiGitBranch, FiGitCommit, FiGitPullRequest } from 'react-icons/fi';

const GitRepository = ({ projectId, projectPath }) => {
  const [gitStatus, setGitStatus] = useState(null);
  const [branches, setBranches] = useState([]);
  const [commits, setCommits] = useState([]);
  const [currentBranch, setCurrentBranch] = useState('main');
  const [commitMessage, setCommitMessage] = useState('');

  useEffect(() => {
    fetchGitData();
  }, [projectId]);

  const fetchGitData = async () => {
    try {
      const [statusRes, branchesRes, commitsRes] = await Promise.all([
        fetch(`/api/git/${projectId}/status`),
        fetch(`/api/git/${projectId}/branches`),
        fetch(`/api/git/${projectId}/commits`)
      ]);

      setGitStatus(await statusRes.json());
      setBranches(await branchesRes.json());
      setCommits(await commitsRes.json());
    } catch (error) {
      console.error('Git data fetch failed:', error);
    }
  };

  const handleCommit = async () => {
    try {
      await fetch(`/api/git/${projectId}/commit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: commitMessage,
          files: gitStatus.changes.map(change => change.file)
        })
      });

      setCommitMessage('');
      fetchGitData();
    } catch (error) {
      console.error('Commit failed:', error);
    }
  };

  const handlePush = async () => {
    try {
      await fetch(`/api/git/${projectId}/push`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ branch: currentBranch })
      });

      fetchGitData();
    } catch (error) {
      console.error('Push failed:', error);
    }
  };

  const handlePull = async () => {
    try {
      await fetch(`/api/git/${projectId}/pull`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ branch: currentBranch })
      });

      fetchGitData();
    } catch (error) {
      console.error('Pull failed:', error);
    }
  };

  return (
    <div className="git-repository">
      <div className="git-header">
        <h3>
          <FiGitBranch /> Git 저장소 관리
        </h3>
        <div className="git-actions">
          <button onClick={handlePull} className="btn-secondary">
            Pull
          </button>
          <button onClick={handlePush} className="btn-primary">
            Push
          </button>
        </div>
      </div>

      {/* 브랜치 선택 */}
      <div className="branch-selector">
        <label>현재 브랜치:</label>
        <select 
          value={currentBranch} 
          onChange={(e) => setCurrentBranch(e.target.value)}
        >
          {branches.filter(b => !b.isRemote).map(branch => (
            <option key={branch.name} value={branch.name}>
              {branch.name}
            </option>
          ))}
        </select>
      </div>

      {/* 변경사항 */}
      {gitStatus?.hasChanges && (
        <div className="git-changes">
          <h4>변경된 파일들</h4>
          <div className="changes-list">
            {gitStatus.changes.map((change, index) => (
              <div key={index} className="change-item">
                <span className={`status ${change.status.toLowerCase()}`}>
                  {change.status}
                </span>
                <span className="file-name">{change.file}</span>
              </div>
            ))}
          </div>

          <div className="commit-form">
            <textarea
              value={commitMessage}
              onChange={(e) => setCommitMessage(e.target.value)}
              placeholder="커밋 메시지를 입력하세요..."
              rows={3}
            />
            <button 
              onClick={handleCommit}
              disabled={!commitMessage.trim()}
              className="btn-primary"
            >
              <FiGitCommit /> 커밋
            </button>
          </div>
        </div>
      )}

      {/* 커밋 히스토리 */}
      <div className="commit-history">
        <h4>최근 커밋</h4>
        <div className="commits-list">
          {commits.map((commit, index) => (
            <div key={index} className="commit-item">
              <div className="commit-hash">{commit.hash}</div>
              <div className="commit-message">{commit.message}</div>
              <div className="commit-meta">
                <span className="commit-author">{commit.author}</span>
                <span className="commit-date">{commit.date}</span>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default GitRepository;
```

### 4. **Docker 통합 관리**

#### **Docker 서비스 (services/dockerService.js)**
```javascript
const { execSync } = require('child_process');
const yaml = require('js-yaml');
const fs = require('fs-extra');
const path = require('path');

class DockerService {
  constructor(workspacePath) {
    this.workspacePath = workspacePath;
  }

  // Docker 컨테이너 상태 조회
  async getContainerStatus() {
    try {
      const containers = execSync(
        'docker ps -a --format "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\\t{{.Image}}"',
        { encoding: 'utf8' }
      );
      
      return this.parseContainerStatus(containers);
    } catch (error) {
      throw new Error(`Get container status failed: ${error.message}`);
    }
  }

  // Docker Compose 서비스 관리
  async manageService(projectId, action) {
    const projectPath = path.join(this.workspacePath, 'projects', projectId);
    const composeFile = path.join(projectPath, 'docker-compose.yml');
    
    if (!fs.existsSync(composeFile)) {
      throw new Error('docker-compose.yml not found');
    }

    try {
      const command = `docker-compose -f ${composeFile} ${action}`;
      const result = execSync(command, {
        cwd: projectPath,
        encoding: 'utf8'
      });
      
      return { success: true, output: result };
    } catch (error) {
      throw new Error(`Docker compose ${action} failed: ${error.message}`);
    }
  }

  // 새 프로젝트 Docker 환경 생성
  async createProjectEnvironment(projectId, config) {
    const projectPath = path.join(this.workspacePath, 'projects', projectId);
    
    // 프로젝트 디렉토리 생성
    await fs.ensureDir(projectPath);
    
    // Docker Compose 파일 생성
    const dockerCompose = this.generateDockerCompose(config);
    await fs.writeFile(
      path.join(projectPath, 'docker-compose.yml'),
      yaml.dump(dockerCompose)
    );
    
    // Dockerfile들 생성
    if (config.backend) {
      await this.createDockerfile(projectPath, 'backend', config.backend);
    }
    
    if (config.frontend) {
      await this.createDockerfile(projectPath, 'frontend', config.frontend);
    }
    
    return true;
  }

  // Docker Compose 설정 생성
  generateDockerCompose(config) {
    const compose = {
      version: '3.8',
      services: {},
      networks: {
        [`${config.projectId}_network`]: {
          driver: 'bridge'
        }
      }
    };

    // 백엔드 서비스
    if (config.backend) {
      compose.services.backend = {
        build: './backend',
        ports: [`${config.backend.port || 4000}:4000`],
        environment: config.backend.environment || {},
        volumes: ['./backend:/app', '/app/node_modules'],
        networks: [`${config.projectId}_network`]
      };
    }

    // 프론트엔드 서비스
    if (config.frontend) {
      compose.services.frontend = {
        build: './frontend',
        ports: [`${config.frontend.port || 20100}:20100`],
        environment: config.frontend.environment || {},
        volumes: ['./frontend:/app', '/app/node_modules'],
        networks: [`${config.projectId}_network`]
      };
    }

    // 데이터베이스 서비스
    if (config.database) {
      if (config.database.mysql) {
        compose.services.mysql = {
          image: 'mysql:8.0',
          environment: {
            MYSQL_ROOT_PASSWORD: config.database.mysql.rootPassword,
            MYSQL_DATABASE: config.database.mysql.database
          },
          ports: ['3306:3306'],
          volumes: ['mysql_data:/var/lib/mysql'],
          networks: [`${config.projectId}_network`]
        };
      }

      if (config.database.postgresql) {
        compose.services.postgresql = {
          image: 'postgres:15',
          environment: {
            POSTGRES_PASSWORD: config.database.postgresql.password,
            POSTGRES_DB: config.database.postgresql.database
          },
          ports: ['5432:5432'],
          volumes: ['postgres_data:/var/lib/postgresql/data'],
          networks: [`${config.projectId}_network`]
        };
      }
    }

    // 볼륨 정의
    compose.volumes = {};
    if (config.database?.mysql) compose.volumes.mysql_data = {};
    if (config.database?.postgresql) compose.volumes.postgres_data = {};

    return compose;
  }

  // Dockerfile 생성
  async createDockerfile(projectPath, type, config) {
    let dockerfile = '';
    
    if (type === 'backend') {
      dockerfile = `
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 4000

CMD ["npm", "start"]
      `.trim();
    } else if (type === 'frontend') {
      dockerfile = `
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 20100

CMD ["npm", "run", "dev"]
      `.trim();
    }

    const dockerfilePath = path.join(projectPath, type, 'Dockerfile');
    await fs.ensureDir(path.dirname(dockerfilePath));
    await fs.writeFile(dockerfilePath, dockerfile);
  }

  parseContainerStatus(containersOutput) {
    const lines = containersOutput.split('\n').slice(1); // 헤더 제거
    return lines.filter(line => line.trim()).map(line => {
      const [name, status, ports, image] = line.split('\t');
      return { name, status, ports, image };
    });
  }

  // 로그 조회
  async getLogs(projectId, service, lines = 100) {
    const projectPath = path.join(this.workspacePath, 'projects', projectId);
    
    try {
      const logs = execSync(
        `docker-compose -f docker-compose.yml logs --tail=${lines} ${service}`,
        { cwd: projectPath, encoding: 'utf8' }
      );
      
      return logs;
    } catch (error) {
      throw new Error(`Get logs failed: ${error.message}`);
    }
  }
}

module.exports = DockerService;
```

### 5. **프로젝트 생성 폼**

#### **ProjectForm.jsx**
```jsx
import React, { useState } from 'react';

const ProjectForm = ({ onSubmit, onCancel, initialData = {} }) => {
  const [formData, setFormData] = useState({
    name: initialData.name || '',
    description: initialData.description || '',
    techStack: {
      backend: initialData.techStack?.backend || 'nodejs',
      frontend: initialData.techStack?.frontend || 'nextjs',
      database: initialData.techStack?.database || 'mysql'
    },
    ports: {
      backend: initialData.ports?.backend || 4000,
      frontend: initialData.ports?.frontend || 20100
    },
    gitRepository: initialData.gitRepository || '',
    environment: initialData.environment || {}
  });

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(formData);
  };

  const updateFormData = (path, value) => {
    setFormData(prev => {
      const newData = { ...prev };
      const keys = path.split('.');
      let current = newData;
      
      for (let i = 0; i < keys.length - 1; i++) {
        current = current[keys[i]];
      }
      current[keys[keys.length - 1]] = value;
      
      return newData;
    });
  };

  return (
    <form onSubmit={handleSubmit} className="project-form">
      <div className="form-group">
        <label>프로젝트 이름</label>
        <input
          type="text"
          value={formData.name}
          onChange={(e) => updateFormData('name', e.target.value)}
          required
        />
      </div>

      <div className="form-group">
        <label>설명</label>
        <textarea
          value={formData.description}
          onChange={(e) => updateFormData('description', e.target.value)}
          rows={3}
        />
      </div>

      <div className="tech-stack">
        <h4>기술 스택</h4>
        
        <div className="form-group">
          <label>백엔드</label>
          <select
            value={formData.techStack.backend}
            onChange={(e) => updateFormData('techStack.backend', e.target.value)}
          >
            <option value="nodejs">Node.js</option>
            <option value="python">Python</option>
            <option value="java">Java</option>
          </select>
        </div>

        <div className="form-group">
          <label>프론트엔드</label>
          <select
            value={formData.techStack.frontend}
            onChange={(e) => updateFormData('techStack.frontend', e.target.value)}
          >
            <option value="nextjs">Next.js</option>
            <option value="sveltekit">SvelteKit</option>
            <option value="react">React</option>
            <option value="vue">Vue.js</option>
          </select>
        </div>

        <div className="form-group">
          <label>데이터베이스</label>
          <select
            value={formData.techStack.database}
            onChange={(e) => updateFormData('techStack.database', e.target.value)}
          >
            <option value="mysql">MySQL</option>
            <option value="postgresql">PostgreSQL</option>
            <option value="mongodb">MongoDB</option>
          </select>
        </div>
      </div>

      <div className="ports">
        <h4>포트 설정</h4>
        
        <div className="form-group">
          <label>백엔드 포트</label>
          <input
            type="number"
            value={formData.ports.backend}
            onChange={(e) => updateFormData('ports.backend', parseInt(e.target.value))}
          />
        </div>

        <div className="form-group">
          <label>프론트엔드 포트</label>
          <input
            type="number"
            value={formData.ports.frontend}
            onChange={(e) => updateFormData('ports.frontend', parseInt(e.target.value))}
          />
        </div>
      </div>

      <div className="form-group">
        <label>Git 저장소 URL</label>
        <input
          type="url"
          value={formData.gitRepository}
          onChange={(e) => updateFormData('gitRepository', e.target.value)}
          placeholder="https://github.com/username/repository.git"
        />
      </div>

      <div className="form-actions">
        <button type="button" onClick={onCancel} className="btn-secondary">
          취소
        </button>
        <button type="submit" className="btn-primary">
          {initialData.id ? '수정' : '생성'}
        </button>
      </div>
    </form>
  );
};

export default ProjectForm;
```

## 🐳 Docker 설정

### **management-hub/docker-compose.yml**
```yaml
version: '3.8'

services:
  management-frontend:
    build: ./frontend
    ports:
      - "20101:20100"
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - ../projects:/workspace/projects:ro
      - ../shared:/workspace/shared:ro
    environment:
      - NODE_ENV=development
      - NEXT_PUBLIC_API_URL=http://localhost:3002
    networks:
      - management_network

  management-backend:
    build: ./backend
    ports:
      - "3002:20100"
    volumes:
      - ./backend:/app
      - /app/node_modules
      - ../projects:/workspace/projects
      - ../shared:/workspace/shared
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://postgres:password@management-db:5432/management
    depends_on:
      - management-db
    networks:
      - management_network

  management-db:
    image: postgres:15
    environment:
      - POSTGRES_DB=management
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - management_db_data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
    networks:
      - management_network

  # Git 서버 (선택사항)
  gitea:
    image: gitea/gitea:latest
    environment:
      - USER_UID=1000
      - USER_GID=1000
    restart: always
    volumes:
      - gitea_data:/data
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    ports:
      - "3003:20100"
      - "222:22"
    networks:
      - management_network

volumes:
  management_db_data:
  gitea_data:

networks:
  management_network:
    driver: bridge
```

## 🎯 주요 기능 요약

### **1. 통합 대시보드**
- 모든 프로젝트 상태 한눈에 보기
- 실시간 활동 피드
- 프로젝트별 통계 및 메트릭

### **2. 프로젝트 관리**
- 새 프로젝트 생성 및 설정
- Docker 환경 자동 구성
- 프로젝트 설정 수정/삭제

### **3. Git 통합 관리**
- 여러 저장소 동시 관리
- 브랜치, 커밋, 푸시/풀 작업
- 코드 변경사항 실시간 모니터링

### **4. 문서 통합 관리**
- 모든 프로젝트 문서 중앙 관리
- 마크다운 편집 및 미리보기
- 전체 문서 검색 기능

### **5. 배포 관리**
- Docker Compose 서비스 제어
- 로그 모니터링
- 컨테이너 상태 관리

이 시스템으로 Docker 환경에서 여러 프로젝트를 효율적으로 통합 관리할 수 있을 것입니다! 특정 부분에 대해 더 자세한 구현이 필요하시면 말씀해 주세요.

===

"""
프로젝트들에 공통으로 사용되는 코딩 컨벤션(사용언어별(nodejs, nextjs, graphql 등) 디렉토리 구조, 파일/클래스/함수/변수 명명법 등)과 claude code 사용시 기획, 개발, 디자인 등에 대한 워크플로우, 표준 문서, 산출 문서 작성에 대한 지침서 등도 있었으면 좋겠네요.
"""

정말 체계적인 접근이네요! 프로젝트 표준화와 일관성을 위한 **종합 가이드라인 시스템**을 만들어보겠습니다. 이는 팀 전체가 동일한 기준으로 작업할 수 있도록 도와줄 것입니다.

## 📋 가이드라인 시스템 구조

### 1. **전체 가이드라인 디렉토리 구조**

```
workspace/
├── guidelines/                      # 가이드라인 중앙 저장소
│   ├── coding-conventions/          # 코딩 컨벤션
│   │   ├── general/                # 공통 규칙
│   │   │   ├── naming-conventions.md
│   │   │   ├── code-formatting.md
│   │   │   ├── comment-standards.md
│   │   │   └── version-control.md
│   │   ├── languages/              # 언어별 컨벤션
│   │   │   ├── javascript/
│   │   │   │   ├── nodejs-conventions.md
│   │   │   │   ├── frontend-conventions.md
│   │   │   │   └── testing-conventions.md
│   │   │   ├── typescript/
│   │   │   │   ├── type-definitions.md
│   │   │   │   ├── interface-conventions.md
│   │   │   │   └── generic-usage.md
│   │   │   ├── graphql/
│   │   │   │   ├── schema-design.md
│   │   │   │   ├── resolver-patterns.md
│   │   │   │   └── query-conventions.md
│   │   │   └── css/
│   │   │       ├── styling-conventions.md
│   │   │       ├── responsive-design.md
│   │   │       └── component-styling.md
│   │   ├── frameworks/             # 프레임워크별 컨벤션
│   │   │   ├── nextjs/
│   │   │   │   ├── project-structure.md
│   │   │   │   ├── page-conventions.md
│   │   │   │   ├── component-conventions.md
│   │   │   │   └── api-routes.md
│   │   │   ├── sveltekit/
│   │   │   │   ├── project-structure.md
│   │   │   │   ├── component-conventions.md
│   │   │   │   └── stores-conventions.md
│   │   │   └── express/
│   │   │       ├── project-structure.md
│   │   │       ├── middleware-conventions.md
│   │   │       └── error-handling.md
│   │   └── database/               # 데이터베이스 컨벤션
│   │       ├── schema-design.md
│   │       ├── migration-conventions.md
│   │       └── query-optimization.md
│   ├── workflows/                  # 워크플로우 가이드
│   │   ├── development/
│   │   │   ├── git-workflow.md
│   │   │   ├── code-review-process.md
│   │   │   ├── testing-workflow.md
│   │   │   └── deployment-workflow.md
│   │   ├── planning/
│   │   │   ├── project-planning.md
│   │   │   ├── requirement-gathering.md
│   │   │   ├── user-story-writing.md
│   │   │   └── estimation-guidelines.md
│   │   ├── design/
│   │   │   ├── design-system.md
│   │   │   ├── ui-ux-guidelines.md
│   │   │   ├── prototyping-workflow.md
│   │   │   └── asset-management.md
│   │   └── claude-ai/              # Claude 활용 워크플로우
│   │       ├── code-generation.md
│   │       ├── documentation-writing.md
│   │       ├── problem-solving.md
│   │       └── best-practices.md
│   ├── documentation/              # 문서 작성 가이드
│   │   ├── standards/
│   │   │   ├── document-structure.md
│   │   │   ├── writing-style.md
│   │   │   ├── markdown-conventions.md
│   │   │   └── diagram-standards.md
│   │   ├── templates/              # 문서 템플릿
│   │   │   ├── project-requirements.md
│   │   │   ├── api-documentation.md
│   │   │   ├── technical-specifications.md
│   │   │   ├── user-manual.md
│   │   │   └── deployment-guide.md
│   │   └── deliverables/           # 산출물 가이드
│   │       ├── planning-deliverables.md
│   │       ├── development-deliverables.md
│   │       ├── testing-deliverables.md
│   │       └── deployment-deliverables.md
│   ├── tools/                      # 도구 설정
│   │   ├── linting/
│   │   │   ├── .eslintrc.js
│   │   │   ├── .prettierrc
│   │   │   └── lint-staged.config.js
│   │   ├── testing/
│   │   │   ├── jest.config.js
│   │   │   ├── cypress.config.js
│   │   │   └── testing-library.config.js
│   │   └── build/
│   │       ├── webpack.config.js
│   │       ├── vite.config.js
│   │       └── rollup.config.js
│   └── checklists/                 # 체크리스트
│       ├── code-review-checklist.md
│       ├── deployment-checklist.md
│       ├── security-checklist.md
│       └── performance-checklist.md
└── management-hub/
    └── frontend/
        └── pages/
            └── guidelines/         # 가이드라인 관리 페이지
                ├── index.js        # 가이드라인 대시보드
                ├── conventions/    # 컨벤션 관리
                ├── workflows/      # 워크플로우 관리
                └── templates/      # 템플릿 관리
```

## 🎯 코딩 컨벤션 상세 가이드

### 1. **Node.js 백엔드 컨벤션 (nodejs-conventions.md)**

```markdown
# Node.js 백엔드 코딩 컨벤션

## 📁 프로젝트 구조

```
backend/
├── src/
│   ├── controllers/          # HTTP 요청 처리
│   │   ├── userController.js
│   │   └── authController.js
│   ├── services/            # 비즈니스 로직
│   │   ├── userService.js
│   │   └── authService.js
│   ├── models/              # 데이터 모델
│   │   ├── User.js
│   │   └── Session.js
│   ├── middleware/          # 미들웨어
│   │   ├── auth.js
│   │   ├── validation.js
│   │   └── errorHandler.js
│   ├── routes/              # 라우트 정의
│   │   ├── index.js
│   │   ├── users.js
│   │   └── auth.js
│   ├── utils/               # 유틸리티 함수
│   │   ├── logger.js
│   │   ├── validators.js
│   │   └── helpers.js
│   ├── config/              # 설정 파일
│   │   ├── database.js
│   │   ├── redis.js
│   │   └── index.js
│   ├── graphql/             # GraphQL 관련
│   │   ├── schemas/
│   │   │   ├── user.graphql
│   │   │   └── index.js
│   │   ├── resolvers/
│   │   │   ├── userResolvers.js
│   │   │   └── index.js
│   │   └── directives/
│   │       └── authDirective.js
│   └── app.js               # 앱 진입점
├── tests/
│   ├── unit/
│   ├── integration/
│   └── fixtures/
├── scripts/
│   ├── migrate.js
│   └── seed.js
├── .env.example
├── package.json
└── README.md
```

## 🏷️ 명명 규칙

### 파일명
- **camelCase** 사용: `userController.js`, `authService.js`
- **클래스 파일**: PascalCase 사용: `User.js`, `DatabaseConnection.js`
- **상수 파일**: UPPER_SNAKE_CASE: `API_CONSTANTS.js`

### 변수명
```javascript
// ✅ 좋은 예시
const userName = 'john_doe';
const isLoggedIn = true;
const userList = [];
const MAX_RETRY_COUNT = 3;

// ❌ 나쁜 예시
const un = 'john_doe';
const flag = true;
const arr = [];
const maxretrycount = 3;
```

### 함수명
```javascript
// ✅ 동사로 시작하는 명확한 함수명
const getUserById = (id) => { /* ... */ };
const createNewUser = (userData) => { /* ... */ };
const validateEmailFormat = (email) => { /* ... */ };
const hasPermission = (user, resource) => { /* ... */ };

// ❌ 모호한 함수명
const user = (id) => { /* ... */ };
const newUser = (userData) => { /* ... */ };
const email = (email) => { /* ... */ };
const permission = (user, resource) => { /* ... */ };
```

### 클래스명
```javascript
// ✅ PascalCase 사용
class UserService {
  constructor() {}
  
  async findUserById(id) {}
  async createUser(userData) {}
}

class DatabaseConnection {
  constructor(config) {}
  
  async connect() {}
  async disconnect() {}
}

// ✅ 인터페이스 구현
class EmailNotificationService extends NotificationService {
  async send(message) {}
}
```

## 🎨 코드 포맷팅

### 함수 구조
```javascript
// ✅ 권장하는 함수 구조
const createUser = async (userData) => {
  try {
    // 1. 입력 검증
    if (!userData || !userData.email) {
      throw new Error('Email is required');
    }
    
    // 2. 비즈니스 로직
    const hashedPassword = await bcrypt.hash(userData.password, 10);
    const user = {
      ...userData,
      password: hashedPassword,
      createdAt: new Date()
    };
    
    // 3. 데이터 처리
    const savedUser = await User.create(user);
    
    // 4. 결과 반환
    return {
      success: true,
      data: savedUser,
      message: 'User created successfully'
    };
  } catch (error) {
    logger.error('Create user failed:', error);
    throw error;
  }
};
```

### 에러 처리
```javascript
// ✅ 일관된 에러 처리
class AppError extends Error {
  constructor(message, statusCode, code) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = true;
  }
}

// 사용 예시
const getUserById = async (id) => {
  if (!id) {
    throw new AppError('User ID is required', 400, 'MISSING_USER_ID');
  }
  
  const user = await User.findById(id);
  if (!user) {
    throw new AppError('User not found', 404, 'USER_NOT_FOUND');
  }
  
  return user;
};
```

### 환경 설정
```javascript
// config/index.js
const config = {
  development: {
    port: process.env.PORT || 20100,
    database: {
      host: process.env.DB_HOST || 'localhost',
      port: process.env.DB_PORT || 5432,
      name: process.env.DB_NAME || 'development',
      username: process.env.DB_USER || 'postgres',
      password: process.env.DB_PASS || 'password'
    },
    redis: {
      host: process.env.REDIS_HOST || 'localhost',
      port: process.env.REDIS_PORT || 6379
    },
    jwt: {
      secret: process.env.JWT_SECRET || 'your-secret-key',
      expiresIn: process.env.JWT_EXPIRES_IN || '7d'
    }
  },
  production: {
    // 프로덕션 설정
  }
};

module.exports = config[process.env.NODE_ENV || 'development'];
```
```

### 2. **Next.js 프론트엔드 컨벤션 (nextjs-conventions.md)**

```markdown
# Next.js 프론트엔드 코딩 컨벤션

## 📁 프로젝트 구조

```
frontend/nextjs-app/
├── pages/                   # Next.js 페이지
│   ├── api/                # API 라우트
│   │   ├── auth/
│   │   │   ├── login.js
│   │   │   └── logout.js
│   │   └── users/
│   │       ├── index.js
│   │       └── [id].js
│   ├── auth/               # 인증 관련 페이지
│   │   ├── login.js
│   │   └── register.js
│   ├── dashboard/          # 대시보드 페이지
│   │   ├── index.js
│   │   └── settings.js
│   ├── _app.js            # 앱 래퍼
│   ├── _document.js       # 문서 래퍼
│   ├── index.js           # 홈 페이지
│   └── 404.js             # 404 페이지
├── components/             # 재사용 가능한 컴포넌트
│   ├── common/            # 공통 컴포넌트
│   │   ├── Header/
│   │   │   ├── Header.jsx
│   │   │   ├── Header.module.css
│   │   │   └── index.js
│   │   ├── Footer/
│   │   ├── Layout/
│   │   └── Loading/
│   ├── forms/             # 폼 관련 컴포넌트
│   │   ├── LoginForm/
│   │   ├── ContactForm/
│   │   └── SearchForm/
│   └── ui/               # UI 컴포넌트
│       ├── Button/
│       ├── Modal/
│       ├── Card/
│       └── Input/
├── hooks/                # 커스텀 훅
│   ├── useAuth.js
│   ├── useApi.js
│   └── useLocalStorage.js
├── lib/                  # 라이브러리와 유틸리티
│   ├── api.js           # API 클라이언트
│   ├── auth.js          # 인증 관련
│   ├── utils.js         # 유틸리티 함수
│   └── constants.js     # 상수
├── styles/              # 스타일 파일
│   ├── globals.css
│   ├── components/
│   └── pages/
├── public/              # 정적 파일
│   ├── images/
│   ├── icons/
│   └── favicon.ico
├── contexts/            # React Context
│   ├── AuthContext.js
│   └── ThemeContext.js
├── types/               # TypeScript 타입 정의
│   ├── auth.ts
│   ├── user.ts
│   └── api.ts
└── __tests__/           # 테스트 파일
    ├── components/
    ├── pages/
    └── utils/
```

## 🧩 컴포넌트 명명 규칙

### 컴포넌트 파일 구조
```
ComponentName/
├── ComponentName.jsx      # 메인 컴포넌트
├── ComponentName.module.css # 스타일 (CSS Modules)
├── ComponentName.test.js  # 테스트 파일
├── index.js              # export 파일
└── README.md             # 컴포넌트 문서
```

### 컴포넌트 작성 패턴
```jsx
// ✅ 권장하는 컴포넌트 구조
import React, { useState, useEffect, useCallback } from 'react';
import PropTypes from 'prop-types';
import styles from './UserCard.module.css';

/**
 * 사용자 정보를 표시하는 카드 컴포넌트
 * @param {Object} user - 사용자 정보 객체
 * @param {Function} onEdit - 편집 버튼 클릭 핸들러
 * @param {boolean} isEditable - 편집 가능 여부
 */
const UserCard = ({
  user,
  onEdit,
  isEditable = false,
  className = ''
}) => {
  // 1. State 정의
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // 2. Effects
  useEffect(() => {
    if (!user?.id) {
      setError('Invalid user data');
    }
  }, [user]);

  // 3. Event Handlers
  const handleEditClick = useCallback(() => {
    if (onEdit && typeof onEdit === 'function') {
      onEdit(user.id);
    }
  }, [onEdit, user.id]);

  const handleImageError = useCallback((e) => {
    e.target.src = '/images/default-avatar.png';
  }, []);

  // 4. Early Returns
  if (!user) {
    return <div className={styles.error}>사용자 정보가 없습니다.</div>;
  }

  if (error) {
    return <div className={styles.error}>{error}</div>;
  }

  // 5. Render
  return (
    <div className={`${styles.userCard} ${className}`}>
      <div className={styles.header}>
        <img
          src={user.avatar || '/images/default-avatar.png'}
          alt={`${user.name} 프로필`}
          className={styles.avatar}
          onError={handleImageError}
        />
        <div className={styles.userInfo}>
          <h3 className={styles.userName}>{user.name}</h3>
          <p className={styles.userEmail}>{user.email}</p>
        </div>
      </div>
      
      <div className={styles.body}>
        <p className={styles.userBio}>
          {user.bio || '소개글이 없습니다.'}
        </p>
      </div>
      
      {isEditable && (
        <div className={styles.footer}>
          <button
            onClick={handleEditClick}
            className={styles.editButton}
            disabled={isLoading}
          >
            {isLoading ? '처리 중...' : '편집'}
          </button>
        </div>
      )}
    </div>
  );
};

// PropTypes 정의
UserCard.propTypes = {
  user: PropTypes.shape({
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    name: PropTypes.string.isRequired,
    email: PropTypes.string.isRequired,
    avatar: PropTypes.string,
    bio: PropTypes.string
  }).isRequired,
  onEdit: PropTypes.func,
  isEditable: PropTypes.bool,
  className: PropTypes.string
};

export default UserCard;
```

### 페이지 컴포넌트 패턴
```jsx
// pages/dashboard/users/index.js
import React from 'react';
import { GetServerSideProps } from 'next';
import Head from 'next/head';
import Layout from '../../../components/common/Layout';
import UserList from '../../../components/users/UserList';
import { getUsers } from '../../../lib/api/users';

const UsersPage = ({ users, error }) => {
  if (error) {
    return (
      <Layout>
        <div className="error-container">
          <h1>오류가 발생했습니다</h1>
          <p>{error}</p>
        </div>
      </Layout>
    );
  }

  return (
    <>
      <Head>
        <title>사용자 관리 - Dashboard</title>
        <meta name="description" content="사용자 목록 및 관리" />
      </Head>
      
      <Layout>
        <div className="users-page">
          <div className="page-header">
            <h1>사용자 관리</h1>
            <p>등록된 사용자들을 관리할 수 있습니다.</p>
          </div>
          
          <UserList users={users} />
        </div>
      </Layout>
    </>
  );
};

// 서버사이드 데이터 페칭
export const getServerSideProps = async (context) => {
  try {
    const users = await getUsers();
    
    return {
      props: {
        users,
        error: null
      }
    };
  } catch (error) {
    return {
      props: {
        users: [],
        error: error.message || '데이터를 불러오는데 실패했습니다.'
      }
    };
  }
};

export default UsersPage;
```

## 🎣 커스텀 훅 패턴

```jsx
// hooks/useApi.js
import { useState, useEffect, useCallback } from 'react';

/**
 * API 호출을 위한 커스텀 훅
 * @param {Function} apiFunction - 호출할 API 함수
 * @param {Array} dependencies - 의존성 배열
 * @param {Object} options - 옵션 객체
 * @returns {Object} { data, loading, error, refetch }
 */
const useApi = (apiFunction, dependencies = [], options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const {
    immediate = true,
    onSuccess,
    onError
  } = options;

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await apiFunction();
      setData(result);
      
      if (onSuccess) {
        onSuccess(result);
      }
    } catch (err) {
      const errorMessage = err.response?.data?.message || err.message;
      setError(errorMessage);
      
      if (onError) {
        onError(err);
      }
    } finally {
      setLoading(false);
    }
  }, dependencies);

  useEffect(() => {
    if (immediate) {
      fetchData();
    }
  }, [fetchData, immediate]);

  return {
    data,
    loading,
    error,
    refetch: fetchData
  };
};

export default useApi;

// 사용 예시
const UserProfile = ({ userId }) => {
  const {
    data: user,
    loading,
    error,
    refetch
  } = useApi(
    () => getUserById(userId),
    [userId],
    {
      onSuccess: (userData) => {
        console.log('User loaded:', userData);
      },
      onError: (error) => {
        console.error('Failed to load user:', error);
      }
    }
  );

  if (loading) return <div>로딩 중...</div>;
  if (error) return <div>오류: {error}</div>;
  if (!user) return <div>사용자를 찾을 수 없습니다.</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={refetch}>새로고침</button>
    </div>
  );
};
```
```

### 3. **GraphQL 컨벤션 (graphql-conventions.md)**

```markdown
# GraphQL 스키마 및 Resolver 컨벤션

## 📋 스키마 설계 원칙

### 1. 타입 명명 규칙
```graphql
# ✅ 권장하는 타입 명명
type User {
  id: ID!
  email: String!
  firstName: String!
  lastName: String!
  fullName: String!
  isActive: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserEdge {
  node: User!
  cursor: String!
}

input CreateUserInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
}

input UpdateUserInput {
  firstName: String
  lastName: String
  isActive: Boolean
}

input UserFilterInput {
  search: String
  isActive: Boolean
  createdAfter: DateTime
  createdBefore: DateTime
}

enum UserRole {
  ADMIN
  MODERATOR
  USER
  GUEST
}

enum UserSortField {
  CREATED_AT
  UPDATED_AT
  NAME
  EMAIL
}
```

### 2. Query 설계 패턴
```graphql
type Query {
  # 단일 리소스 조회 (ID 기반)
  user(id: ID!): User
  
  # 단일 리소스 조회 (다른 필드 기반)
  userByEmail(email: String!): User
  
  # 목록 조회 (페이지네이션)
  users(
    first: Int = 10
    after: String
    filter: UserFilterInput
    sortBy: UserSortField = CREATED_AT
    sortOrder: SortOrder = DESC
  ): UserConnection!
  
  # 검색
  searchUsers(
    query: String!
    first: Int = 10
    after: String
  ): UserConnection!
  
  # 집계 데이터
  userStats: UserStats!
}

# 페이지네이션을 위한 공통 타입
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum SortOrder {
  ASC
  DESC
}
```

### 3. Mutation 설계 패턴
```graphql
type Mutation {
  # 생성 연산
  createUser(input: CreateUserInput!): CreateUserPayload!
  
  # 수정 연산
  updateUser(id: ID!, input: UpdateUserInput!): UpdateUserPayload!
  
  # 삭제 연산
  deleteUser(id: ID!): DeleteUserPayload!
  
  # 배치 연산
  createUsers(input: [CreateUserInput!]!): CreateUsersPayload!
  updateUsers(ids: [ID!]!, input: UpdateUserInput!): UpdateUsersPayload!
  deleteUsers(ids: [ID!]!): DeleteUsersPayload!
  
  # 상태 변경 연산
  activateUser(id: ID!): ActivateUserPayload!
  deactivateUser(id: ID!): DeactivateUserPayload!
}

# Payload 타입 (결과 + 오류 정보)
type CreateUserPayload {
  user: User
  errors: [UserError!]!
  success: Boolean!
}

type UserError {
  field: String
  message: String!
  code: String!
}
```

## 🔧 Resolver 패턴

### 1. Resolver 구조
```javascript
// resolvers/userResolvers.js

const userResolvers = {
  Query: {
    user: async (parent, { id }, context) => {
      return await context.dataSources.userAPI.getUserById(id);
    },
    
    users: async (parent, args, context) => {
      const { first, after, filter, sortBy, sortOrder } = args;
      
      return await context.dataSources.userAPI.getUsers({
        limit: first,
        cursor: after,
        filter,
        sortBy,
        sortOrder
      });
    }
  },

  Mutation: {
    createUser: async (parent, { input }, context) => {
      try {
        // 1. 권한 확인
        if (!context.user || !context.user.hasPermission('CREATE_USER')) {
          return {
            user: null,
            errors: [{
              code: 'UNAUTHORIZED',
              message: '사용자 생성 권한이 없습니다.'
            }],
            success: false
          };
        }

        // 2. 입력 검증
        const validationErrors = validateCreateUserInput(input);
        if (validationErrors.length > 0) {
          return {
            user: null,
            errors: validationErrors,
            success: false
          };
        }

        // 3. 비즈니스 로직 실행
        const user = await context.dataSources.userAPI.createUser(input);

        // 4. 성공 응답
        return {
          user,
          errors: [],
          success: true
        };
      } catch (error) {
        // 5. 오류 처리
        context.logger.error('Create user failed:', error);
        
        return {
          user: null,
          errors: [{
            code: 'INTERNAL_ERROR',
            message: '사용자 생성 중 오류가 발생했습니다.'
          }],
          success: false
        };
      }
    }
  },

  User: {
    // 필드 resolver
    fullName: (parent) => {
      return `${parent.firstName} ${parent.lastName}`;
    },
    
    // 관계 resolver
    posts: async (parent, args, context) => {
      return await context.dataSources.postAPI.getPostsByUserId(parent.id);
    },
    
    // 계산된 필드
    isOnline: async (parent, args, context) => {
      return await context.dataSources.userAPI.checkUserOnlineStatus(parent.id);
    }
  }
};

// 입력 검증 함수
const validateCreateUserInput = (input) => {
  const errors = [];
  
  if (!input.email || !isValidEmail(input.email)) {
    errors.push({
      field: 'email',
      code: 'INVALID_EMAIL',
      message: '유효한 이메일 주소를 입력해주세요.'
    });
  }
  
  if (!input.password || input.password.length < 8) {
    errors.push({
      field: 'password',
      code: 'WEAK_PASSWORD',
      message: '비밀번호는 8자 이상이어야 합니다.'
    });
  }
  
  return errors;
};

module.exports = userResolvers;
```

### 2. DataSource 패턴
```javascript
// dataSources/UserAPI.js
const { DataSource } = require('apollo-datasource');

class UserAPI extends DataSource {
  constructor() {
    super();
  }

  initialize(config) {
    this.context = config.context;
    this.cache = config.cache;
  }

  async getUserById(id) {
    // 캐시 확인
    const cacheKey = `user:${id}`;
    const cached = await this.cache.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }

    // 데이터베이스에서 조회
    const user = await this.context.db.User.findByPk(id);
    
    if (user) {
      // 캐시에 저장
      await this.cache.set(cacheKey, JSON.stringify(user), 300); // 5분
    }
    
    return user;
  }

  async getUsers({ limit = 10, cursor, filter, sortBy, sortOrder }) {
    const offset = cursor ? decodeCursor(cursor) : 0;
    
    const queryOptions = {
      limit: limit + 1, // hasNextPage 확인을 위해 +1
      offset,
      order: [[sortBy, sortOrder]]
    };

    // 필터 적용
    if (filter) {
      queryOptions.where = this.buildWhereClause(filter);
    }

    const users = await this.context.db.User.findAll(queryOptions);
    
    const hasNextPage = users.length > limit;
    const edges = users.slice(0, limit).map((user, index) => ({
      node: user,
      cursor: encodeCursor(offset + index)
    }));

    return {
      edges,
      pageInfo: {
        hasNextPage,
        hasPreviousPage: offset > 0,
        startCursor: edges.length > 0 ? edges[0].cursor : null,
        endCursor: edges.length > 0 ? edges[edges.length - 1].cursor : null
      },
      totalCount: await this.getUserCount(filter)
    };
  }

  buildWhereClause(filter) {
    const where = {};
    
    if (filter.search) {
      where[Op.or] = [
        { firstName: { [Op.iLike]: `%${filter.search}%` } },
        { lastName: { [Op.iLike]: `%${filter.search}%` } },
        { email: { [Op.iLike]: `%${filter.search}%` } }
      ];
    }
    
    if (filter.isActive !== undefined) {
      where.isActive = filter.isActive;
    }
    
    if (filter.createdAfter) {
      where.createdAt = { [Op.gte]: filter.createdAfter };
    }
    
    if (filter.createdBefore) {
      where.createdAt = { 
        ...where.createdAt,
        [Op.lte]: filter.createdBefore 
      };
    }
    
    return where;
  }
}

module.exports = UserAPI;
```
```

## 🚀 Claude AI 활용 워크플로우

### 4. **Claude 코드 생성 워크플로우 (claude-code-generation.md)**

```markdown
# Claude AI 활용 개발 워크플로우

## 🎯 기본 원칙

### 1. 명확한 요청 구조화
Claude에게 요청할 때는 다음 구조를 따르세요:

```
**컨텍스트**: 현재 프로젝트 상황과 기술 스택
**목표**: 구현하고자 하는 기능이나 해결하고자 하는 문제
**요구사항**: 구체적인 기능 요구사항과 제약사항
**입력/출력**: 예상되는 입력과 출력 형태
**고려사항**: 성능, 보안, 확장성 등의 고려사항
```

### 2. 단계별 개발 접근법

#### Phase 1: 계획 수립
```markdown
Claude에게 요청하는 예시:

**컨텍스트**: Next.js 13 앱에서 사용자 관리 시스템을 구축 중입니다. 
현재 Next.js App Router, TypeScript, Prisma ORM, PostgreSQL을 사용합니다.

**목표**: 사용자 목록을 보여주고 필터링/검색이 가능한 페이지를 만들고 싶습니다.

**요구사항**:
- 페이지네이션 (한 페이지당 20개)
- 이름, 이메일, 가입일로 검색 가능
- 활성/비활성 상태로 필터링
- 반응형 디자인
- 로딩 상태 및 에러 처리

**고려사항**:
- SEO 최적화 필요
- 성능상 서버사이드 렌더링 선호
- 접근성 고려

이 요구사항에 맞는 파일 구조와 구현 계획을 제안해주세요.
```

#### Phase 2: 코드 생성
```markdown
이전에 제안해주신 구조를 바탕으로, 다음 컴포넌트들을 구현해주세요:

1. `app/users/page.tsx` - 메인 사용자 목록 페이지
2. `components/UserList.tsx` - 사용자 목록 컴포넌트
3. `components/UserFilters.tsx` - 필터링 컴포넌트
4. `lib/userService.ts` - 사용자 데이터 처리 서비스

각 파일에 대해:
- 우리의 코딩 컨벤션을 따라주세요
- TypeScript를 엄격하게 적용해주세요
- 에러 처리와 로딩 상태를 포함해주세요
- 테스트 코드도 함께 제공해주세요
```

### 3. 코드 리뷰 및 개선

#### 리뷰 요청 패턴
```markdown
다음 코드를 우리의 컨벤션과 베스트 프랙티스 관점에서 리뷰해주세요:

[코드 첨부]

특히 다음 사항을 중점적으로 확인해주세요:
- 코딩 컨벤션 준수 여부
- 성능 최적화 가능성
- 보안 취약점
- 접근성 고려사항
- 테스트 가능성
- 유지보수성

개선사항이 있다면 수정된 코드와 함께 설명해주세요.
```

## 📋 워크플로우별 Claude 활용법

### 1. 기획 단계
```markdown
# 요구사항 분석 요청
다음 프로젝트 요구사항을 분석하고 구조화해주세요:

[요구사항 문서 첨부]

다음 형태로 정리해주세요:
1. 핵심 기능 목록
2. 기술적 요구사항
3. 비기능적 요구사항 (성능, 보안, 확장성)
4. 위험 요소 및 고려사항
5. 개발 우선순위 제안
6. 예상 개발 일정
```

### 2. 설계 단계
```markdown
# 아키텍처 설계 요청
다음 요구사항을 바탕으로 시스템 아키텍처를 설계해주세요:

**기능 요구사항**: [앞서 분석된 요구사항]
**기술 스택**: Next.js, Node.js, GraphQL, PostgreSQL, Redis
**제약사항**: Docker 환경, 마이크로서비스 지향

다음을 포함해서 설계해주세요:
1. 전체 시스템 아키텍처 다이어그램 (Mermaid 형식)
2. 데이터베이스 ERD
3. API 설계 (GraphQL 스키마)
4. 컴포넌트 구조도
5. 디렉토리 구조
```

### 3. 개발 단계
```markdown
# 기능 구현 요청
다음 GraphQL resolver를 구현해주세요:

**기능**: 사용자 생성 mutation
**입력**: CreateUserInput { email, firstName, lastName, password }
**출력**: CreateUserPayload { user, errors, success }
**비즈니스 로직**:
- 이메일 중복 검사
- 비밀번호 해싱
- 이메일 검증 발송
- 활동 로그 기록

**적용할 패턴**:
- 우리의 resolver 컨벤션
- 에러 처리 패턴
- 로깅 패턴
- 테스트 코드 포함
```

### 4. 테스트 단계
```markdown
# 테스트 코드 생성 요청
다음 컴포넌트에 대한 포괄적인 테스트 코드를 작성해주세요:

[컴포넌트 코드 첨부]

다음 테스트를 포함해주세요:
1. 렌더링 테스트
2. 사용자 인터랙션 테스트
3. 에러 상황 테스트
4. 접근성 테스트
5. 성능 테스트 (필요시)

Testing Library와 Jest를 사용해주세요.
```

### 5. 문서화 단계
```markdown
# API 문서 생성 요청
다음 GraphQL 스키마에 대한 상세한 API 문서를 작성해주세요:

[GraphQL 스키마 첨부]

포함할 내용:
1. 각 Query/Mutation의 목적과 사용법
2. 입력 매개변수 설명
3. 응답 데이터 구조
4. 에러 코드 및 처리 방법
5. 사용 예시 (요청/응답)
6. 권한 요구사항
7. 제한사항 (Rate limiting 등)

Markdown 형식으로 작성해주세요.
```

## 🔄 반복 개선 프로세스

### 1. 코드 개선 사이클
```markdown
# 리팩토링 요청
다음 코드를 더 깔끔하고 유지보수하기 쉽게 리팩토링해주세요:

[기존 코드 첨부]

고려사항:
- 코드 가독성 향상
- 성능 최적화
- 재사용성 증대
- 테스트 용이성
- SOLID 원칙 적용

변경사항에 대한 설명도 함께 제공해주세요.
```

### 2. 버그 수정 요청
```markdown
# 버그 분석 및 수정 요청
다음 코드에서 발생하는 문제를 분석하고 수정해주세요:

**문제 상황**: [구체적인 문제 설명]
**재현 방법**: [문제 재현 단계]
**예상 동작**: [원래 기대했던 동작]
**현재 동작**: [실제 발생하는 동작]

[문제가 있는 코드 첨부]

수정된 코드와 함께 문제의 원인과 해결 방법을 설명해주세요.
```

## 💡 효율적인 Claude 활용 팁

### 1. 컨텍스트 관리
- 프로젝트 표준과 컨벤션을 처음에 명확히 전달
- 기존 코드 스타일을 예시로 제공
- 기술 스택과 제약사항을 항상 명시

### 2. 점진적 개발
- 한 번에 너무 많은 기능을 요청하지 말고 단계별로 진행
- 이전 결과물을 다음 요청의 컨텍스트로 활용
- 피드백을 바탕으로 지속적으로 개선

### 3. 품질 보장
- 항상 테스트 코드를 함께 요청
- 에러 처리와 엣지 케이스 고려를 명시
- 코드 리뷰를 별도로 요청

### 4. 문서화
- 생성된 코드에 대한 문서를 함께 요청
- 의사결정 과정과 근거를 기록
- 향후 유지보수를 위한 가이드 생성
```

## 📝 표준 문서 템플릿

### 5. **프로젝트 요구사항 템플릿 (project-requirements.md)**

```markdown
# 프로젝트 요구사항 명세서

## 📋 프로젝트 개요

### 프로젝트 정보
- **프로젝트명**: 
- **버전**: 
- **작성자**: 
- **작성일**: 
- **승인자**: 
- **승인일**: 

### 프로젝트 목적
- **배경**: 
- **목표**: 
- **기대효과**: 

## 🎯 기능 요구사항

### 핵심 기능
| 기능 ID | 기능명 | 우선순위 | 설명 | 담당자 | 예상 공수 |
|---------|--------|----------|------|---------|----------|
| F001    |        | High     |      |         |          |
| F002    |        | Medium   |      |         |          |

### 상세 기능 명세

#### F001. [기능명]
- **목적**: 
- **사용자 스토리**: "As a [사용자], I want [기능] so that [목적]"
- **수용 기준**:
  - [ ] 기준 1
  - [ ] 기준 2
- **전제 조건**: 
- **후속 조건**: 
- **예외 상황**: 

## 🔧 기술 요구사항

### 기술 스택
- **Frontend**: 
- **Backend**: 
- **Database**: 
- **Infrastructure**: 

### 성능 요구사항
- **응답 시간**: 
- **동시 사용자**: 
- **데이터 처리량**: 
- **가용성**: 

### 보안 요구사항
- **인증/인가**: 
- **데이터 암호화**: 
- **개인정보 보호**: 
- **보안 표준**: 

## 📱 사용자 인터페이스 요구사항

### 화면 구성
| 화면 ID | 화면명 | 설명 | 관련 기능 |
|---------|--------|------|-----------|
| UI001   |        |      |           |

### UX 가이드라인
- **접근성**: 
- **반응형**: 
- **브라우저 지원**: 

## 🔗 시스템 연동 요구사항

### 외부 시스템
| 시스템명 | 연동 방식 | 목적 | 담당자 |
|----------|-----------|------|---------|
|          |           |      |         |

### API 요구사항
- **API 방식**: 
- **인증 방식**: 
- **데이터 형식**: 

## 📊 데이터 요구사항

### 데이터 모델
```mermaid
erDiagram
    USER {
        id int
        email string
        name string
    }
```

### 데이터 마이그레이션
- **기존 데이터**: 
- **마이그레이션 방식**: 
- **백업 계획**: 

## 🚀 배포 및 운영 요구사항

### 배포 환경
- **개발**: 
- **스테이징**: 
- **프로덕션**: 

### 모니터링
- **로그 수집**: 
- **성능 모니터링**: 
- **오류 추적**: 

## ⚠️ 제약사항 및 위험요소

### 제약사항
- **예산**: 
- **일정**: 
- **기술적 제약**: 

### 위험요소
| 위험요소 | 발생 확률 | 영향도 | 대응 방안 |
|----------|-----------|--------|-----------|
|          |           |        |           |

## 📅 일정 계획

### 마일스톤
| 단계 | 기간 | 주요 산출물 | 담당자 |
|------|------|-------------|---------|
| 기획 |      |             |         |
| 설계 |      |             |         |
| 개발 |      |             |         |
| 테스트 |    |             |         |
| 배포 |      |             |         |

## ✅ 승인 및 검토

### 검토 이력
| 버전 | 날짜 | 변경 내용 | 작성자 |
|------|------|-----------|---------|
| 1.0  |      | 초기 작성 |         |

### 승인
- **기획팀**: ☐ 승인 / ☐ 검토 중 / ☐ 반려
- **개발팀**: ☐ 승인 / ☐ 검토 중 / ☐ 반려
- **디자인팀**: ☐ 승인 / ☐ 검토 중 / ☐ 반려
```

이 가이드라인 시스템을 통해 팀 전체가 일관된 품질의 코드와 문서를 생산할 수 있을 것입니다. 특정 부분에 대해 더 자세한 가이드라인이 필요하시면 말씀해 주세요!
