
"""
Redis는 어떤 상황에서 사용하는 건가요?
"""

excellent 질문이네요! Redis는 **메모리 기반 고속 데이터 저장소**로, 우리가 구축하는 개발 환경에서 여러 핵심적인 역할을 합니다. 구체적인 사용 사례들을 설명해드리겠습니다.

## 🚀 Redis 주요 사용 사례

### 1. **사용자 세션 관리 (Session Store)**

#### **문제 상황:**
- 여러 프로젝트에서 동일한 사용자가 로그인
- API Gateway를 통한 분산 서비스 간 세션 공유
- 로그아웃 시 모든 서비스에서 세션 무효화 필요

#### **Redis 활용:**
```javascript
// auth-service/src/services/sessionService.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class SessionService {
  // 세션 저장
  async createSession(userId, sessionData) {
    const sessionId = `session:${userId}:${Date.now()}`;
    const sessionKey = `user_session:${sessionId}`;
    
    await client.setEx(sessionKey, 3600 * 24 * 7, JSON.stringify({
      userId,
      email: sessionData.email,
      roles: sessionData.roles,
      projects: sessionData.projects,
      createdAt: new Date().toISOString(),
      lastActivity: new Date().toISOString()
    }));
    
    // 사용자별 활성 세션 목록 관리
    await client.sAdd(`user_sessions:${userId}`, sessionId);
    
    return sessionId;
  }

  // 세션 조회
  async getSession(sessionId) {
    const sessionKey = `user_session:${sessionId}`;
    const sessionData = await client.get(sessionKey);
    
    if (sessionData) {
      const session = JSON.parse(sessionData);
      // 마지막 활동 시간 업데이트
      session.lastActivity = new Date().toISOString();
      await client.setEx(sessionKey, 3600 * 24 * 7, JSON.stringify(session));
      return session;
    }
    
    return null;
  }

  // 모든 세션 무효화 (로그아웃)
  async invalidateAllUserSessions(userId) {
    const sessionIds = await client.sMembers(`user_sessions:${userId}`);
    
    for (const sessionId of sessionIds) {
      await client.del(`user_session:${sessionId}`);
    }
    
    await client.del(`user_sessions:${userId}`);
  }

  // 특정 프로젝트 접근 권한 캐싱
  async cacheProjectPermissions(userId, projectId, permissions) {
    const key = `permissions:${userId}:${projectId}`;
    await client.setEx(key, 3600, JSON.stringify(permissions)); // 1시간 캐시
  }
}

module.exports = new SessionService();
```

### 2. **API 응답 캐싱 (Response Caching)**

#### **문제 상황:**
- 데이터베이스 조회가 많은 API 엔드포인트 성능 저하
- 자주 조회되지만 변경이 적은 데이터 (사용자 정보, 권한 등)
- 외부 API 호출 결과 캐싱

#### **Redis 활용:**
```javascript
// shared/middleware/cacheMiddleware.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class CacheMiddleware {
  // API 응답 캐싱 미들웨어
  cache(ttl = 300) { // 기본 5분
    return async (req, res, next) => {
      const cacheKey = this.generateCacheKey(req);
      
      try {
        const cachedData = await client.get(cacheKey);
        
        if (cachedData) {
          console.log(`Cache HIT: ${cacheKey}`);
          return res.json({
            ...JSON.parse(cachedData),
            cached: true,
            cacheTime: new Date().toISOString()
          });
        }
        
        // 원래 응답을 가로채서 캐싱
        const originalSend = res.json;
        res.json = function(data) {
          if (res.statusCode === 200) {
            client.setEx(cacheKey, ttl, JSON.stringify(data));
          }
          originalSend.call(this, data);
        };
        
        next();
      } catch (error) {
        console.error('Cache error:', error);
        next();
      }
    };
  }

  generateCacheKey(req) {
    const { method, path, query, user } = req;
    const userKey = user ? user.id : 'anonymous';
    return `api_cache:${method}:${path}:${userKey}:${JSON.stringify(query)}`;
  }

  // 캐시 무효화
  async invalidateCache(pattern) {
    const keys = await client.keys(pattern);
    if (keys.length > 0) {
      await client.del(keys);
    }
  }
}

// 사용 예시
// GET /api/users/:id (사용자 정보 조회 - 자주 바뀌지 않음)
app.get('/api/users/:id', cacheMiddleware.cache(1800), getUserById); // 30분 캐시

// GET /api/projects (프로젝트 목록 - 가끔 변경)
app.get('/api/projects', cacheMiddleware.cache(600), getProjects); // 10분 캐시
```

### 3. **실시간 알림 시스템 (Pub/Sub)**

#### **문제 상황:**
- 프로젝트 배포 상태 실시간 알림
- 새로운 사용자 가입 알림
- 시스템 상태 변경 브로드캐스트

#### **Redis 활용:**
```javascript
// shared/services/notificationService.js
const redis = require('redis');

class NotificationService {
  constructor() {
    this.publisher = redis.createClient({ url: process.env.REDIS_URL });
    this.subscriber = redis.createClient({ url: process.env.REDIS_URL });
    this.setupSubscriptions();
  }

  // 알림 발행
  async publishNotification(channel, message) {
    const notification = {
      id: `notif_${Date.now()}`,
      timestamp: new Date().toISOString(),
      channel,
      ...message
    };
    
    await this.publisher.publish(channel, JSON.stringify(notification));
    
    // 알림 히스토리 저장 (최근 100개만)
    await this.publisher.lPush(`notifications:${channel}`, JSON.stringify(notification));
    await this.publisher.lTrim(`notifications:${channel}`, 0, 99);
  }

  // 구독 설정
  setupSubscriptions() {
    // 프로젝트 관련 알림
    this.subscriber.subscribe('project:created', (message) => {
      const data = JSON.parse(message);
      console.log(`새 프로젝트 생성: ${data.projectName}`);
      // WebSocket으로 관리자에게 전송
      this.broadcastToAdmins('project_created', data);
    });

    // 배포 상태 알림
    this.subscriber.subscribe('deployment:status', (message) => {
      const data = JSON.parse(message);
      console.log(`배포 상태 변경: ${data.projectId} - ${data.status}`);
      // 해당 프로젝트 멤버들에게 알림
      this.notifyProjectMembers(data.projectId, 'deployment_status', data);
    });

    // 시스템 알림
    this.subscriber.subscribe('system:alert', (message) => {
      const data = JSON.parse(message);
      console.log(`시스템 알림: ${data.message}`);
      // 모든 사용자에게 브로드캐스트
      this.broadcastToAll('system_alert', data);
    });
  }

  // 사용 예시들
  async notifyProjectCreated(projectData) {
    await this.publishNotification('project:created', {
      type: 'PROJECT_CREATED',
      projectId: projectData.id,
      projectName: projectData.name,
      createdBy: projectData.createdBy
    });
  }

  async notifyDeploymentStatus(projectId, status, details) {
    await this.publishNotification('deployment:status', {
      type: 'DEPLOYMENT_STATUS',
      projectId,
      status, // 'building', 'deploying', 'success', 'failed'
      details,
      timestamp: new Date().toISOString()
    });
  }
}

module.exports = new NotificationService();
```

### 4. **Rate Limiting (속도 제한)**

#### **문제 상황:**
- API 남용 방지
- 무료 사용자와 유료 사용자의 차등 제한
- DDoS 공격 방어

#### **Redis 활용:**
```javascript
// api-gateway/src/middleware/rateLimiter.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class RateLimiter {
  // 기본 속도 제한
  async isAllowed(identifier, limit = 100, window = 3600) {
    const key = `rate_limit:${identifier}`;
    
    const current = await client.incr(key);
    
    if (current === 1) {
      await client.expire(key, window);
    }
    
    return {
      allowed: current <= limit,
      current,
      limit,
      remaining: Math.max(0, limit - current),
      resetTime: await client.ttl(key)
    };
  }

  // 슬라이딩 윈도우 방식
  async slidingWindow(identifier, limit = 100, window = 3600) {
    const key = `sliding_limit:${identifier}`;
    const now = Date.now();
    const windowStart = now - (window * 1000);
    
    // 만료된 요청 제거
    await client.zRemRangeByScore(key, '-inf', windowStart);
    
    // 현재 요청 수 확인
    const currentCount = await client.zCard(key);
    
    if (currentCount < limit) {
      // 현재 요청 추가
      await client.zAdd(key, [{score: now, value: `${now}-${Math.random()}`}]);
      await client.expire(key, window);
      
      return {
        allowed: true,
        current: currentCount + 1,
        limit,
        remaining: limit - currentCount - 1
      };
    }
    
    return {
      allowed: false,
      current: currentCount,
      limit,
      remaining: 0
    };
  }

  // 사용자별 차등 제한
  async checkUserLimit(req, res, next) {
    const userId = req.user?.id || req.ip;
    const userType = req.user?.type || 'anonymous';
    
    // 사용자 타입별 제한
    const limits = {
      'anonymous': { limit: 10, window: 60 },     // 분당 10회
      'user': { limit: 100, window: 60 },         // 분당 100회
      'premium': { limit: 1000, window: 60 },     // 분당 1000회
      'admin': { limit: 10000, window: 60 }       // 분당 10000회
    };
    
    const { limit, window } = limits[userType] || limits['anonymous'];
    const result = await this.slidingWindow(userId, limit, window);
    
    // 응답 헤더에 제한 정보 추가
    res.set({
      'X-RateLimit-Limit': limit,
      'X-RateLimit-Remaining': result.remaining,
      'X-RateLimit-Used': result.current
    });
    
    if (!result.allowed) {
      return res.status(429).json({
        error: 'Too Many Requests',
        message: `Rate limit exceeded. Try again in ${window} seconds.`,
        retryAfter: window
      });
    }
    
    next();
  }
}

module.exports = new RateLimiter();
```

### 5. **분산 락 (Distributed Lock)**

#### **문제 상황:**
- 여러 서비스에서 동시에 같은 리소스 수정 시도
- 데이터베이스 생성/삭제 작업의 동시성 제어
- 배포 프로세스 중복 실행 방지

#### **Redis 활용:**
```javascript
// shared/services/lockService.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class LockService {
  async acquireLock(lockKey, ttl = 30, retryDelay = 100, maxRetries = 50) {
    const lockValue = `${Date.now()}-${Math.random()}`;
    let retries = 0;
    
    while (retries < maxRetries) {
      const result = await client.set(
        `lock:${lockKey}`, 
        lockValue, 
        'EX', ttl, 
        'NX'
      );
      
      if (result === 'OK') {
        return {
          acquired: true,
          lockValue,
          release: () => this.releaseLock(lockKey, lockValue)
        };
      }
      
      await new Promise(resolve => setTimeout(resolve, retryDelay));
      retries++;
    }
    
    return { acquired: false };
  }

  async releaseLock(lockKey, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    return await client.eval(script, 1, `lock:${lockKey}`, lockValue);
  }

  // 사용 예시: 데이터베이스 생성 시 중복 방지
  async createProjectDatabase(projectId, config) {
    const lock = await this.acquireLock(`db_creation:${projectId}`, 60);
    
    if (!lock.acquired) {
      throw new Error('Another database creation is in progress');
    }
    
    try {
      // 실제 데이터베이스 생성 로직
      const result = await databaseService.createDatabase(projectId, config);
      return result;
    } finally {
      await lock.release();
    }
  }
}

module.exports = new LockService();
```

### 6. **작업 큐 (Job Queue)**

#### **문제 상황:**
- 시간이 오래 걸리는 작업 (이메일 발송, 파일 처리, 배포)
- 백그라운드 작업 처리
- 작업 우선순위 관리

#### **Redis 활용:**
```javascript
// shared/services/jobQueue.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class JobQueue {
  // 작업 추가
  async addJob(queueName, jobData, priority = 0, delay = 0) {
    const job = {
      id: `job_${Date.now()}_${Math.random()}`,
      data: jobData,
      createdAt: new Date().toISOString(),
      attempts: 0,
      maxAttempts: 3
    };
    
    const queueKey = `queue:${queueName}`;
    const score = Date.now() + (delay * 1000) + (priority * 1000000);
    
    await client.zAdd(queueKey, [{score, value: JSON.stringify(job)}]);
    
    // 작업 상태 추적
    await client.hSet(`job:${job.id}`, {
      status: 'pending',
      queue: queueName,
      ...job
    });
    
    return job.id;
  }

  // 작업 처리
  async processJobs(queueName, processor) {
    const queueKey = `queue:${queueName}`;
    
    while (true) {
      try {
        // 처리할 작업 가져오기
        const jobs = await client.zRangeByScore(queueKey, 0, Date.now(), {
          LIMIT: { offset: 0, count: 1 }
        });
        
        if (jobs.length === 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
          continue;
        }
        
        const jobData = JSON.parse(jobs[0]);
        
        // 작업 상태 업데이트
        await client.hSet(`job:${jobData.id}`, 'status', 'processing');
        
        try {
          // 실제 작업 처리
          const result = await processor(jobData.data);
          
          // 성공 처리
          await client.zRem(queueKey, jobs[0]);
          await client.hSet(`job:${jobData.id}`, {
            status: 'completed',
            result: JSON.stringify(result),
            completedAt: new Date().toISOString()
          });
          
        } catch (error) {
          // 실패 처리
          jobData.attempts++;
          
          if (jobData.attempts >= jobData.maxAttempts) {
            // 최대 재시도 초과
            await client.zRem(queueKey, jobs[0]);
            await client.hSet(`job:${jobData.id}`, {
              status: 'failed',
              error: error.message,
              failedAt: new Date().toISOString()
            });
          } else {
            // 재시도
            const retryDelay = Math.pow(2, jobData.attempts) * 1000; // 지수적 백오프
            const retryScore = Date.now() + retryDelay;
            
            await client.zRem(queueKey, jobs[0]);
            await client.zAdd(queueKey, [{
              score: retryScore, 
              value: JSON.stringify(jobData)
            }]);
            
            await client.hSet(`job:${jobData.id}`, {
              status: 'retrying',
              attempts: jobData.attempts,
              nextRetry: new Date(Date.now() + retryDelay).toISOString()
            });
          }
        }
        
      } catch (error) {
        console.error('Job processing error:', error);
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }
  }
}

// 사용 예시
const jobQueue = new JobQueue();

// 이메일 발송 작업 추가
await jobQueue.addJob('email', {
  to: 'user@example.com',
  subject: 'Welcome!',
  template: 'welcome',
  data: { userName: 'John' }
});

// 배포 작업 추가 (높은 우선순위)
await jobQueue.addJob('deployment', {
  projectId: 'project-1',
  branch: 'main',
  environment: 'production'
}, 10); // 높은 우선순위

// 작업 처리기 시작
jobQueue.processJobs('email', async (jobData) => {
  return await emailService.sendEmail(jobData);
});

jobQueue.processJobs('deployment', async (jobData) => {
  return await deploymentService.deploy(jobData);
});
```

## 🎯 우리 시스템에서의 Redis 활용 정리

### **필수 사용 사례:**
1. **사용자 세션 관리** - 다중 프로젝트 간 로그인 상태 공유
2. **API 캐싱** - 자주 조회되는 사용자/프로젝트 정보 캐싱
3. **Rate Limiting** - API 남용 방지

### **확장 시 유용한 사용 사례:**
4. **실시간 알림** - 배포 상태, 시스템 알림
5. **분산 락** - 데이터베이스 생성 등 중요 작업 동시성 제어
6. **작업 큐** - 이메일 발송, 배포 작업 등 백그라운드 처리

### **성능상 이점:**
- **메모리 기반**: 디스크 I/O 없이 초고속 데이터 접근
- **단순한 데이터 구조**: 빠른 읽기/쓰기
- **네트워크 최적화**: 바이너리 프로토콜로 낮은 레이턴시

Redis 없이도 시스템은 동작하지만, **성능, 확장성, 사용자 경험** 측면에서 큰 차이가 납니다! 특히 여러 프로젝트가 동시에 돌아가는 환경에서는 거의 필수적이라고 볼 수 있어요.
