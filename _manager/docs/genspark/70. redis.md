
"""
RedisëŠ” ì–´ë–¤ ìƒí™©ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê±´ê°€ìš”?
"""

excellent ì§ˆë¬¸ì´ë„¤ìš”! RedisëŠ” **ë©”ëª¨ë¦¬ ê¸°ë°˜ ê³ ì† ë°ì´í„° ì €ì¥ì†Œ**ë¡œ, ìš°ë¦¬ê°€ êµ¬ì¶•í•˜ëŠ” ê°œë°œ í™˜ê²½ì—ì„œ ì—¬ëŸ¬ í•µì‹¬ì ì¸ ì—­í• ì„ í•©ë‹ˆë‹¤. êµ¬ì²´ì ì¸ ì‚¬ìš© ì‚¬ë¡€ë“¤ì„ ì„¤ëª…í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

## ğŸš€ Redis ì£¼ìš” ì‚¬ìš© ì‚¬ë¡€

### 1. **ì‚¬ìš©ì ì„¸ì…˜ ê´€ë¦¬ (Session Store)**

#### **ë¬¸ì œ ìƒí™©:**
- ì—¬ëŸ¬ í”„ë¡œì íŠ¸ì—ì„œ ë™ì¼í•œ ì‚¬ìš©ìê°€ ë¡œê·¸ì¸
- API Gatewayë¥¼ í†µí•œ ë¶„ì‚° ì„œë¹„ìŠ¤ ê°„ ì„¸ì…˜ ê³µìœ 
- ë¡œê·¸ì•„ì›ƒ ì‹œ ëª¨ë“  ì„œë¹„ìŠ¤ì—ì„œ ì„¸ì…˜ ë¬´íš¨í™” í•„ìš”

#### **Redis í™œìš©:**
```javascript
// auth-service/src/services/sessionService.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class SessionService {
  // ì„¸ì…˜ ì €ì¥
  async createSession(userId, sessionData) {
    const sessionId = `session:${userId}:${Date.now()}`;
    const sessionKey = `user_session:${sessionId}`;
    
    await client.setEx(sessionKey, 3600 * 24 * 7, JSON.stringify({
      userId,
      email: sessionData.email,
      roles: sessionData.roles,
      projects: sessionData.projects,
      createdAt: new Date().toISOString(),
      lastActivity: new Date().toISOString()
    }));
    
    // ì‚¬ìš©ìë³„ í™œì„± ì„¸ì…˜ ëª©ë¡ ê´€ë¦¬
    await client.sAdd(`user_sessions:${userId}`, sessionId);
    
    return sessionId;
  }

  // ì„¸ì…˜ ì¡°íšŒ
  async getSession(sessionId) {
    const sessionKey = `user_session:${sessionId}`;
    const sessionData = await client.get(sessionKey);
    
    if (sessionData) {
      const session = JSON.parse(sessionData);
      // ë§ˆì§€ë§‰ í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸
      session.lastActivity = new Date().toISOString();
      await client.setEx(sessionKey, 3600 * 24 * 7, JSON.stringify(session));
      return session;
    }
    
    return null;
  }

  // ëª¨ë“  ì„¸ì…˜ ë¬´íš¨í™” (ë¡œê·¸ì•„ì›ƒ)
  async invalidateAllUserSessions(userId) {
    const sessionIds = await client.sMembers(`user_sessions:${userId}`);
    
    for (const sessionId of sessionIds) {
      await client.del(`user_session:${sessionId}`);
    }
    
    await client.del(`user_sessions:${userId}`);
  }

  // íŠ¹ì • í”„ë¡œì íŠ¸ ì ‘ê·¼ ê¶Œí•œ ìºì‹±
  async cacheProjectPermissions(userId, projectId, permissions) {
    const key = `permissions:${userId}:${projectId}`;
    await client.setEx(key, 3600, JSON.stringify(permissions)); // 1ì‹œê°„ ìºì‹œ
  }
}

module.exports = new SessionService();
```

### 2. **API ì‘ë‹µ ìºì‹± (Response Caching)**

#### **ë¬¸ì œ ìƒí™©:**
- ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒê°€ ë§ì€ API ì—”ë“œí¬ì¸íŠ¸ ì„±ëŠ¥ ì €í•˜
- ìì£¼ ì¡°íšŒë˜ì§€ë§Œ ë³€ê²½ì´ ì ì€ ë°ì´í„° (ì‚¬ìš©ì ì •ë³´, ê¶Œí•œ ë“±)
- ì™¸ë¶€ API í˜¸ì¶œ ê²°ê³¼ ìºì‹±

#### **Redis í™œìš©:**
```javascript
// shared/middleware/cacheMiddleware.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class CacheMiddleware {
  // API ì‘ë‹µ ìºì‹± ë¯¸ë“¤ì›¨ì–´
  cache(ttl = 300) { // ê¸°ë³¸ 5ë¶„
    return async (req, res, next) => {
      const cacheKey = this.generateCacheKey(req);
      
      try {
        const cachedData = await client.get(cacheKey);
        
        if (cachedData) {
          console.log(`Cache HIT: ${cacheKey}`);
          return res.json({
            ...JSON.parse(cachedData),
            cached: true,
            cacheTime: new Date().toISOString()
          });
        }
        
        // ì›ë˜ ì‘ë‹µì„ ê°€ë¡œì±„ì„œ ìºì‹±
        const originalSend = res.json;
        res.json = function(data) {
          if (res.statusCode === 200) {
            client.setEx(cacheKey, ttl, JSON.stringify(data));
          }
          originalSend.call(this, data);
        };
        
        next();
      } catch (error) {
        console.error('Cache error:', error);
        next();
      }
    };
  }

  generateCacheKey(req) {
    const { method, path, query, user } = req;
    const userKey = user ? user.id : 'anonymous';
    return `api_cache:${method}:${path}:${userKey}:${JSON.stringify(query)}`;
  }

  // ìºì‹œ ë¬´íš¨í™”
  async invalidateCache(pattern) {
    const keys = await client.keys(pattern);
    if (keys.length > 0) {
      await client.del(keys);
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
// GET /api/users/:id (ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ - ìì£¼ ë°”ë€Œì§€ ì•ŠìŒ)
app.get('/api/users/:id', cacheMiddleware.cache(1800), getUserById); // 30ë¶„ ìºì‹œ

// GET /api/projects (í”„ë¡œì íŠ¸ ëª©ë¡ - ê°€ë” ë³€ê²½)
app.get('/api/projects', cacheMiddleware.cache(600), getProjects); // 10ë¶„ ìºì‹œ
```

### 3. **ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ (Pub/Sub)**

#### **ë¬¸ì œ ìƒí™©:**
- í”„ë¡œì íŠ¸ ë°°í¬ ìƒíƒœ ì‹¤ì‹œê°„ ì•Œë¦¼
- ìƒˆë¡œìš´ ì‚¬ìš©ì ê°€ì… ì•Œë¦¼
- ì‹œìŠ¤í…œ ìƒíƒœ ë³€ê²½ ë¸Œë¡œë“œìºìŠ¤íŠ¸

#### **Redis í™œìš©:**
```javascript
// shared/services/notificationService.js
const redis = require('redis');

class NotificationService {
  constructor() {
    this.publisher = redis.createClient({ url: process.env.REDIS_URL });
    this.subscriber = redis.createClient({ url: process.env.REDIS_URL });
    this.setupSubscriptions();
  }

  // ì•Œë¦¼ ë°œí–‰
  async publishNotification(channel, message) {
    const notification = {
      id: `notif_${Date.now()}`,
      timestamp: new Date().toISOString(),
      channel,
      ...message
    };
    
    await this.publisher.publish(channel, JSON.stringify(notification));
    
    // ì•Œë¦¼ íˆìŠ¤í† ë¦¬ ì €ì¥ (ìµœê·¼ 100ê°œë§Œ)
    await this.publisher.lPush(`notifications:${channel}`, JSON.stringify(notification));
    await this.publisher.lTrim(`notifications:${channel}`, 0, 99);
  }

  // êµ¬ë… ì„¤ì •
  setupSubscriptions() {
    // í”„ë¡œì íŠ¸ ê´€ë ¨ ì•Œë¦¼
    this.subscriber.subscribe('project:created', (message) => {
      const data = JSON.parse(message);
      console.log(`ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±: ${data.projectName}`);
      // WebSocketìœ¼ë¡œ ê´€ë¦¬ìì—ê²Œ ì „ì†¡
      this.broadcastToAdmins('project_created', data);
    });

    // ë°°í¬ ìƒíƒœ ì•Œë¦¼
    this.subscriber.subscribe('deployment:status', (message) => {
      const data = JSON.parse(message);
      console.log(`ë°°í¬ ìƒíƒœ ë³€ê²½: ${data.projectId} - ${data.status}`);
      // í•´ë‹¹ í”„ë¡œì íŠ¸ ë©¤ë²„ë“¤ì—ê²Œ ì•Œë¦¼
      this.notifyProjectMembers(data.projectId, 'deployment_status', data);
    });

    // ì‹œìŠ¤í…œ ì•Œë¦¼
    this.subscriber.subscribe('system:alert', (message) => {
      const data = JSON.parse(message);
      console.log(`ì‹œìŠ¤í…œ ì•Œë¦¼: ${data.message}`);
      // ëª¨ë“  ì‚¬ìš©ìì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
      this.broadcastToAll('system_alert', data);
    });
  }

  // ì‚¬ìš© ì˜ˆì‹œë“¤
  async notifyProjectCreated(projectData) {
    await this.publishNotification('project:created', {
      type: 'PROJECT_CREATED',
      projectId: projectData.id,
      projectName: projectData.name,
      createdBy: projectData.createdBy
    });
  }

  async notifyDeploymentStatus(projectId, status, details) {
    await this.publishNotification('deployment:status', {
      type: 'DEPLOYMENT_STATUS',
      projectId,
      status, // 'building', 'deploying', 'success', 'failed'
      details,
      timestamp: new Date().toISOString()
    });
  }
}

module.exports = new NotificationService();
```

### 4. **Rate Limiting (ì†ë„ ì œí•œ)**

#### **ë¬¸ì œ ìƒí™©:**
- API ë‚¨ìš© ë°©ì§€
- ë¬´ë£Œ ì‚¬ìš©ìì™€ ìœ ë£Œ ì‚¬ìš©ìì˜ ì°¨ë“± ì œí•œ
- DDoS ê³µê²© ë°©ì–´

#### **Redis í™œìš©:**
```javascript
// api-gateway/src/middleware/rateLimiter.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class RateLimiter {
  // ê¸°ë³¸ ì†ë„ ì œí•œ
  async isAllowed(identifier, limit = 100, window = 3600) {
    const key = `rate_limit:${identifier}`;
    
    const current = await client.incr(key);
    
    if (current === 1) {
      await client.expire(key, window);
    }
    
    return {
      allowed: current <= limit,
      current,
      limit,
      remaining: Math.max(0, limit - current),
      resetTime: await client.ttl(key)
    };
  }

  // ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë°©ì‹
  async slidingWindow(identifier, limit = 100, window = 3600) {
    const key = `sliding_limit:${identifier}`;
    const now = Date.now();
    const windowStart = now - (window * 1000);
    
    // ë§Œë£Œëœ ìš”ì²­ ì œê±°
    await client.zRemRangeByScore(key, '-inf', windowStart);
    
    // í˜„ì¬ ìš”ì²­ ìˆ˜ í™•ì¸
    const currentCount = await client.zCard(key);
    
    if (currentCount < limit) {
      // í˜„ì¬ ìš”ì²­ ì¶”ê°€
      await client.zAdd(key, [{score: now, value: `${now}-${Math.random()}`}]);
      await client.expire(key, window);
      
      return {
        allowed: true,
        current: currentCount + 1,
        limit,
        remaining: limit - currentCount - 1
      };
    }
    
    return {
      allowed: false,
      current: currentCount,
      limit,
      remaining: 0
    };
  }

  // ì‚¬ìš©ìë³„ ì°¨ë“± ì œí•œ
  async checkUserLimit(req, res, next) {
    const userId = req.user?.id || req.ip;
    const userType = req.user?.type || 'anonymous';
    
    // ì‚¬ìš©ì íƒ€ì…ë³„ ì œí•œ
    const limits = {
      'anonymous': { limit: 10, window: 60 },     // ë¶„ë‹¹ 10íšŒ
      'user': { limit: 100, window: 60 },         // ë¶„ë‹¹ 100íšŒ
      'premium': { limit: 1000, window: 60 },     // ë¶„ë‹¹ 1000íšŒ
      'admin': { limit: 10000, window: 60 }       // ë¶„ë‹¹ 10000íšŒ
    };
    
    const { limit, window } = limits[userType] || limits['anonymous'];
    const result = await this.slidingWindow(userId, limit, window);
    
    // ì‘ë‹µ í—¤ë”ì— ì œí•œ ì •ë³´ ì¶”ê°€
    res.set({
      'X-RateLimit-Limit': limit,
      'X-RateLimit-Remaining': result.remaining,
      'X-RateLimit-Used': result.current
    });
    
    if (!result.allowed) {
      return res.status(429).json({
        error: 'Too Many Requests',
        message: `Rate limit exceeded. Try again in ${window} seconds.`,
        retryAfter: window
      });
    }
    
    next();
  }
}

module.exports = new RateLimiter();
```

### 5. **ë¶„ì‚° ë½ (Distributed Lock)**

#### **ë¬¸ì œ ìƒí™©:**
- ì—¬ëŸ¬ ì„œë¹„ìŠ¤ì—ì„œ ë™ì‹œì— ê°™ì€ ë¦¬ì†ŒìŠ¤ ìˆ˜ì • ì‹œë„
- ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±/ì‚­ì œ ì‘ì—…ì˜ ë™ì‹œì„± ì œì–´
- ë°°í¬ í”„ë¡œì„¸ìŠ¤ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€

#### **Redis í™œìš©:**
```javascript
// shared/services/lockService.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class LockService {
  async acquireLock(lockKey, ttl = 30, retryDelay = 100, maxRetries = 50) {
    const lockValue = `${Date.now()}-${Math.random()}`;
    let retries = 0;
    
    while (retries < maxRetries) {
      const result = await client.set(
        `lock:${lockKey}`, 
        lockValue, 
        'EX', ttl, 
        'NX'
      );
      
      if (result === 'OK') {
        return {
          acquired: true,
          lockValue,
          release: () => this.releaseLock(lockKey, lockValue)
        };
      }
      
      await new Promise(resolve => setTimeout(resolve, retryDelay));
      retries++;
    }
    
    return { acquired: false };
  }

  async releaseLock(lockKey, lockValue) {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    
    return await client.eval(script, 1, `lock:${lockKey}`, lockValue);
  }

  // ì‚¬ìš© ì˜ˆì‹œ: ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì‹œ ì¤‘ë³µ ë°©ì§€
  async createProjectDatabase(projectId, config) {
    const lock = await this.acquireLock(`db_creation:${projectId}`, 60);
    
    if (!lock.acquired) {
      throw new Error('Another database creation is in progress');
    }
    
    try {
      // ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ë¡œì§
      const result = await databaseService.createDatabase(projectId, config);
      return result;
    } finally {
      await lock.release();
    }
  }
}

module.exports = new LockService();
```

### 6. **ì‘ì—… í (Job Queue)**

#### **ë¬¸ì œ ìƒí™©:**
- ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—… (ì´ë©”ì¼ ë°œì†¡, íŒŒì¼ ì²˜ë¦¬, ë°°í¬)
- ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì²˜ë¦¬
- ì‘ì—… ìš°ì„ ìˆœìœ„ ê´€ë¦¬

#### **Redis í™œìš©:**
```javascript
// shared/services/jobQueue.js
const redis = require('redis');
const client = redis.createClient({ url: process.env.REDIS_URL });

class JobQueue {
  // ì‘ì—… ì¶”ê°€
  async addJob(queueName, jobData, priority = 0, delay = 0) {
    const job = {
      id: `job_${Date.now()}_${Math.random()}`,
      data: jobData,
      createdAt: new Date().toISOString(),
      attempts: 0,
      maxAttempts: 3
    };
    
    const queueKey = `queue:${queueName}`;
    const score = Date.now() + (delay * 1000) + (priority * 1000000);
    
    await client.zAdd(queueKey, [{score, value: JSON.stringify(job)}]);
    
    // ì‘ì—… ìƒíƒœ ì¶”ì 
    await client.hSet(`job:${job.id}`, {
      status: 'pending',
      queue: queueName,
      ...job
    });
    
    return job.id;
  }

  // ì‘ì—… ì²˜ë¦¬
  async processJobs(queueName, processor) {
    const queueKey = `queue:${queueName}`;
    
    while (true) {
      try {
        // ì²˜ë¦¬í•  ì‘ì—… ê°€ì ¸ì˜¤ê¸°
        const jobs = await client.zRangeByScore(queueKey, 0, Date.now(), {
          LIMIT: { offset: 0, count: 1 }
        });
        
        if (jobs.length === 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
          continue;
        }
        
        const jobData = JSON.parse(jobs[0]);
        
        // ì‘ì—… ìƒíƒœ ì—…ë°ì´íŠ¸
        await client.hSet(`job:${jobData.id}`, 'status', 'processing');
        
        try {
          // ì‹¤ì œ ì‘ì—… ì²˜ë¦¬
          const result = await processor(jobData.data);
          
          // ì„±ê³µ ì²˜ë¦¬
          await client.zRem(queueKey, jobs[0]);
          await client.hSet(`job:${jobData.id}`, {
            status: 'completed',
            result: JSON.stringify(result),
            completedAt: new Date().toISOString()
          });
          
        } catch (error) {
          // ì‹¤íŒ¨ ì²˜ë¦¬
          jobData.attempts++;
          
          if (jobData.attempts >= jobData.maxAttempts) {
            // ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼
            await client.zRem(queueKey, jobs[0]);
            await client.hSet(`job:${jobData.id}`, {
              status: 'failed',
              error: error.message,
              failedAt: new Date().toISOString()
            });
          } else {
            // ì¬ì‹œë„
            const retryDelay = Math.pow(2, jobData.attempts) * 1000; // ì§€ìˆ˜ì  ë°±ì˜¤í”„
            const retryScore = Date.now() + retryDelay;
            
            await client.zRem(queueKey, jobs[0]);
            await client.zAdd(queueKey, [{
              score: retryScore, 
              value: JSON.stringify(jobData)
            }]);
            
            await client.hSet(`job:${jobData.id}`, {
              status: 'retrying',
              attempts: jobData.attempts,
              nextRetry: new Date(Date.now() + retryDelay).toISOString()
            });
          }
        }
        
      } catch (error) {
        console.error('Job processing error:', error);
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
const jobQueue = new JobQueue();

// ì´ë©”ì¼ ë°œì†¡ ì‘ì—… ì¶”ê°€
await jobQueue.addJob('email', {
  to: 'user@example.com',
  subject: 'Welcome!',
  template: 'welcome',
  data: { userName: 'John' }
});

// ë°°í¬ ì‘ì—… ì¶”ê°€ (ë†’ì€ ìš°ì„ ìˆœìœ„)
await jobQueue.addJob('deployment', {
  projectId: 'project-1',
  branch: 'main',
  environment: 'production'
}, 10); // ë†’ì€ ìš°ì„ ìˆœìœ„

// ì‘ì—… ì²˜ë¦¬ê¸° ì‹œì‘
jobQueue.processJobs('email', async (jobData) => {
  return await emailService.sendEmail(jobData);
});

jobQueue.processJobs('deployment', async (jobData) => {
  return await deploymentService.deploy(jobData);
});
```

## ğŸ¯ ìš°ë¦¬ ì‹œìŠ¤í…œì—ì„œì˜ Redis í™œìš© ì •ë¦¬

### **í•„ìˆ˜ ì‚¬ìš© ì‚¬ë¡€:**
1. **ì‚¬ìš©ì ì„¸ì…˜ ê´€ë¦¬** - ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ê°„ ë¡œê·¸ì¸ ìƒíƒœ ê³µìœ 
2. **API ìºì‹±** - ìì£¼ ì¡°íšŒë˜ëŠ” ì‚¬ìš©ì/í”„ë¡œì íŠ¸ ì •ë³´ ìºì‹±
3. **Rate Limiting** - API ë‚¨ìš© ë°©ì§€

### **í™•ì¥ ì‹œ ìœ ìš©í•œ ì‚¬ìš© ì‚¬ë¡€:**
4. **ì‹¤ì‹œê°„ ì•Œë¦¼** - ë°°í¬ ìƒíƒœ, ì‹œìŠ¤í…œ ì•Œë¦¼
5. **ë¶„ì‚° ë½** - ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ë“± ì¤‘ìš” ì‘ì—… ë™ì‹œì„± ì œì–´
6. **ì‘ì—… í** - ì´ë©”ì¼ ë°œì†¡, ë°°í¬ ì‘ì—… ë“± ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬

### **ì„±ëŠ¥ìƒ ì´ì :**
- **ë©”ëª¨ë¦¬ ê¸°ë°˜**: ë””ìŠ¤í¬ I/O ì—†ì´ ì´ˆê³ ì† ë°ì´í„° ì ‘ê·¼
- **ë‹¨ìˆœí•œ ë°ì´í„° êµ¬ì¡°**: ë¹ ë¥¸ ì½ê¸°/ì“°ê¸°
- **ë„¤íŠ¸ì›Œí¬ ìµœì í™”**: ë°”ì´ë„ˆë¦¬ í”„ë¡œí† ì½œë¡œ ë‚®ì€ ë ˆì´í„´ì‹œ

Redis ì—†ì´ë„ ì‹œìŠ¤í…œì€ ë™ì‘í•˜ì§€ë§Œ, **ì„±ëŠ¥, í™•ì¥ì„±, ì‚¬ìš©ì ê²½í—˜** ì¸¡ë©´ì—ì„œ í° ì°¨ì´ê°€ ë‚©ë‹ˆë‹¤! íŠ¹íˆ ì—¬ëŸ¬ í”„ë¡œì íŠ¸ê°€ ë™ì‹œì— ëŒì•„ê°€ëŠ” í™˜ê²½ì—ì„œëŠ” ê±°ì˜ í•„ìˆ˜ì ì´ë¼ê³  ë³¼ ìˆ˜ ìˆì–´ìš”.
